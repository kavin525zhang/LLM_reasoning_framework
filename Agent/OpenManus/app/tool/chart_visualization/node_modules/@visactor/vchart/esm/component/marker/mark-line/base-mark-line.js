import { DataView } from "@visactor/vdataset";

import { markerAggregation } from "../../../data/transforms/aggregation";

import { computeClipRange, transformLabelAttributes, transformState, transformStyle, getMarkLineProcessInfo } from "../utils";

import { registerDataSetInstanceTransform } from "../../../data/register";

import { transformToGraphic } from "../../../util/style";

import { BaseMarker } from "../base-marker";

import { markerRegression } from "../../../data/transforms/regression";

import { LayoutZIndex } from "../../../constant/layout";

import { markerFilter } from "../../../data/transforms/marker-filter";

export class BaseMarkLine extends BaseMarker {
    constructor() {
        super(...arguments), this.specKey = "markLine", this.layoutZIndex = LayoutZIndex.MarkLine;
    }
    static _getMarkerCoordinateType(markerSpec) {
        const {doAngleProcess: doAngleProcess, doRadiusProcess: doRadiusProcess, doAngRadRad1Process: doAngRadRad1Process, doRadAngAng1Process: doRadAngAng1Process, doRadAngProcess: doRadAngProcess} = getMarkLineProcessInfo(markerSpec);
        return "polar" === markerSpec.coordinateType || doAngleProcess || doRadiusProcess || doAngRadRad1Process || doRadAngAng1Process || doRadAngProcess ? "polar" : "cartesian";
    }
    _createMarkerComponent() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        const {label: label = {}, startSymbol: startSymbol = {}, endSymbol: endSymbol = {}} = this._spec, markLineAttrs = {
            zIndex: this.layoutZIndex,
            interactive: null === (_a = this._spec.interactive) || void 0 === _a || _a,
            hover: null === (_b = this._spec.interactive) || void 0 === _b || _b,
            select: null === (_c = this._spec.interactive) || void 0 === _c || _c,
            points: [ {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            } ],
            center: {
                x: 0,
                y: 0
            },
            radius: 0,
            startAngle: 0,
            endAngle: 0,
            lineStyle: transformStyle(transformToGraphic(null === (_d = this._spec.line) || void 0 === _d ? void 0 : _d.style), this._markerData, this._markAttributeContext),
            clipInRange: null !== (_e = this._spec.clip) && void 0 !== _e && _e,
            label: transformLabelAttributes(label, this._markerData, this._markAttributeContext),
            state: {
                line: transformState(null !== (_g = null === (_f = this._spec.line) || void 0 === _f ? void 0 : _f.state) && void 0 !== _g ? _g : {}, this._markerData, this._markAttributeContext),
                lineStartSymbol: transformState(null !== (_j = null === (_h = this._spec.startSymbol) || void 0 === _h ? void 0 : _h.state) && void 0 !== _j ? _j : {}, this._markerData, this._markAttributeContext),
                lineEndSymbol: transformState(null !== (_l = null === (_k = this._spec.endSymbol) || void 0 === _k ? void 0 : _k.state) && void 0 !== _l ? _l : {}, this._markerData, this._markAttributeContext),
                label: transformState(null !== (_p = null === (_o = null === (_m = this._spec) || void 0 === _m ? void 0 : _m.label) || void 0 === _o ? void 0 : _o.state) && void 0 !== _p ? _p : {}, this._markerData, this._markAttributeContext),
                labelBackground: transformState(null !== (_t = null === (_s = null === (_r = null === (_q = this._spec) || void 0 === _q ? void 0 : _q.label) || void 0 === _r ? void 0 : _r.labelBackground) || void 0 === _s ? void 0 : _s.state) && void 0 !== _t ? _t : {}, this._markerData, this._markAttributeContext)
            },
            animation: null !== (_u = this._spec.animation) && void 0 !== _u && _u,
            animationEnter: this._spec.animationEnter,
            animationExit: this._spec.animationExit,
            animationUpdate: this._spec.animationUpdate
        };
        startSymbol.visible ? markLineAttrs.startSymbol = Object.assign(Object.assign({}, startSymbol), {
            visible: !0,
            style: transformStyle(transformToGraphic(startSymbol.style), this._markerData, this._markAttributeContext)
        }) : markLineAttrs.startSymbol = {
            visible: !1
        }, endSymbol.visible ? markLineAttrs.endSymbol = Object.assign(Object.assign({}, endSymbol), {
            visible: !0,
            style: transformStyle(transformToGraphic(endSymbol.style), this._markerData, this._markAttributeContext)
        }) : markLineAttrs.endSymbol = {
            visible: !1
        };
        return this._newMarkLineComponent(markLineAttrs);
    }
    _getUpdateMarkerAttrs() {
        var _a, _b, _c, _d;
        const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, pointsAttr = this._computePointsAttr(), seriesData = relativeSeries.getViewData().latestData, dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData;
        let limitRect;
        if (spec.clip || (null === (_a = spec.label) || void 0 === _a ? void 0 : _a.confine)) {
            const {minX: minX, maxX: maxX, minY: minY, maxY: maxY} = computeClipRange([ startRelativeSeries.getRegion(), endRelativeSeries.getRegion(), relativeSeries.getRegion() ]);
            limitRect = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
        const markerComponentAttr = null !== (_c = null === (_b = this._markerComponent) || void 0 === _b ? void 0 : _b.attribute) && void 0 !== _c ? _c : {}, labelAttrs = Object.assign(Object.assign({}, markerComponentAttr.label), {
            text: this._spec.label.formatMethod ? this._spec.label.formatMethod(dataPoints, seriesData) : null === (_d = markerComponentAttr.label) || void 0 === _d ? void 0 : _d.text
        });
        return Object.assign(Object.assign({}, pointsAttr), {
            label: labelAttrs,
            limitRect: limitRect,
            dx: this._layoutOffsetX,
            dy: this._layoutOffsetY
        });
    }
    _markerLayout() {
        var _a;
        const updateAttrs = this._getUpdateMarkerAttrs();
        null === (_a = this._markerComponent) || void 0 === _a || _a.setAttributes(updateAttrs);
    }
    _initDataView() {
        const spec = this._spec, isCoordinateProcess = "coordinates" in spec, {doXProcess: doXProcess, doYProcess: doYProcess, doXYY1Process: doXYY1Process, doYXX1Process: doYXX1Process, doXYProcess: doXYProcess, doAngleProcess: doAngleProcess, doRadiusProcess: doRadiusProcess, doAngRadRad1Process: doAngRadRad1Process, doRadAngAng1Process: doRadAngAng1Process, doRadAngProcess: doRadAngProcess} = getMarkLineProcessInfo(spec);
        if (this._markerData = this._getRelativeDataView(), !(doXProcess || doYProcess || doXYY1Process || doYXX1Process || doXYProcess || doAngleProcess || doRadiusProcess || doAngRadRad1Process || doRadAngAng1Process || doRadAngProcess || isCoordinateProcess)) return;
        registerDataSetInstanceTransform(this._option.dataSet, "markerAggregation", markerAggregation), 
        registerDataSetInstanceTransform(this._option.dataSet, "markerRegression", markerRegression), 
        registerDataSetInstanceTransform(this._option.dataSet, "markerFilter", markerFilter);
        const {options: options, needAggr: needAggr, needRegr: needRegr, processData: processData} = this._computeOptions(), data = new DataView(this._option.dataSet);
        data.parse([ processData ], {
            type: "dataview"
        }), needAggr && data.transform({
            type: "markerAggregation",
            options: options
        }), needRegr && data.transform({
            type: "markerRegression",
            options: options
        }), data.transform({
            type: "markerFilter",
            options: this._getAllRelativeSeries()
        }), data.target.on("change", (() => {
            this._markerLayout();
        })), this._markerData = data;
    }
}

BaseMarkLine.specKey = "markLine";
//# sourceMappingURL=base-mark-line.js.map
