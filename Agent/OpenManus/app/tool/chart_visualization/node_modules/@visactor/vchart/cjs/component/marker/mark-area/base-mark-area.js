"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseMarkArea = void 0;

const utils_1 = require("../utils"), style_1 = require("../../../util/style"), base_marker_1 = require("../base-marker"), layout_1 = require("../../../constant/layout");

class BaseMarkArea extends base_marker_1.BaseMarker {
    constructor() {
        super(...arguments), this.specKey = "markArea", this.layoutZIndex = layout_1.LayoutZIndex.MarkArea;
    }
    static _getMarkerCoordinateType(markerSpec) {
        const {doAngleProcess: doAngleProcess, doRadiusProcess: doRadiusProcess, doRadAngProcess: doRadAngProcess} = (0, 
        utils_1.getMarkAreaProcessInfo)(markerSpec);
        return "polar" === markerSpec.coordinateType || doAngleProcess || doRadiusProcess || doRadAngProcess ? "polar" : "cartesian";
    }
    _createMarkerComponent() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const label = null !== (_a = this._spec.label) && void 0 !== _a ? _a : {}, markAreaAttrs = {
            zIndex: this.layoutZIndex,
            interactive: null === (_b = this._spec.interactive) || void 0 === _b || _b,
            hover: null === (_c = this._spec.interactive) || void 0 === _c || _c,
            select: null === (_d = this._spec.interactive) || void 0 === _d || _d,
            points: [ {
                x: 0,
                y: 0
            } ],
            center: {
                x: 0,
                y: 0
            },
            innerRadius: 0,
            outerRadius: 0,
            startAngle: 0,
            endAngle: 0,
            areaStyle: (0, utils_1.transformStyle)((0, style_1.transformToGraphic)(null === (_e = this._spec.area) || void 0 === _e ? void 0 : _e.style), this._markerData, this._markAttributeContext),
            clipInRange: null !== (_f = this._spec.clip) && void 0 !== _f && _f,
            label: (0, utils_1.transformLabelAttributes)(label, this._markerData, this._markAttributeContext),
            state: {
                area: (0, utils_1.transformState)(null === (_g = this._spec.area) || void 0 === _g ? void 0 : _g.state, this._markerData, this._markAttributeContext),
                label: (0, utils_1.transformState)(null === (_h = this._spec.label) || void 0 === _h ? void 0 : _h.state, this._markerData, this._markAttributeContext),
                labelBackground: (0, utils_1.transformState)(null === (_l = null === (_k = null === (_j = this._spec) || void 0 === _j ? void 0 : _j.label) || void 0 === _k ? void 0 : _k.labelBackground) || void 0 === _l ? void 0 : _l.state, this._markerData, this._markAttributeContext)
            },
            animation: null !== (_m = this._spec.animation) && void 0 !== _m && _m,
            animationEnter: this._spec.animationEnter,
            animationExit: this._spec.animationExit,
            animationUpdate: this._spec.animationUpdate
        };
        return this._newMarkAreaComponent(markAreaAttrs);
    }
    _markerLayout() {
        var _a, _b, _c, _d;
        const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, pointsAttr = this._computePointsAttr(), seriesData = this._getRelativeDataView().latestData, dataPoints = data ? data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData : seriesData;
        let limitRect;
        if (spec.clip || (null === (_a = spec.label) || void 0 === _a ? void 0 : _a.confine)) {
            const {minX: minX, maxX: maxX, minY: minY, maxY: maxY} = (0, utils_1.computeClipRange)([ startRelativeSeries.getRegion(), endRelativeSeries.getRegion(), relativeSeries.getRegion() ]);
            limitRect = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
        this._markerComponent && this._markerComponent.setAttributes(Object.assign(Object.assign({}, pointsAttr), {
            label: Object.assign(Object.assign({}, null === (_b = this._markerComponent.attribute) || void 0 === _b ? void 0 : _b.label), {
                text: this._spec.label.formatMethod ? this._spec.label.formatMethod(dataPoints, seriesData) : null === (_d = null === (_c = this._markerComponent.attribute) || void 0 === _c ? void 0 : _c.label) || void 0 === _d ? void 0 : _d.text
            }),
            limitRect: limitRect,
            dx: this._layoutOffsetX,
            dy: this._layoutOffsetY
        }));
    }
    _initDataView() {
        const spec = this._spec, {doXProcess: doXProcess, doYProcess: doYProcess, doXYProcess: doXYProcess, doAngleProcess: doAngleProcess, doRadiusProcess: doRadiusProcess, doRadAngProcess: doRadAngProcess, doCoordinatesProcess: doCoordinatesProcess} = (0, 
        utils_1.getMarkAreaProcessInfo)(spec);
        if (!(doXProcess || doYProcess || doXYProcess || doAngleProcess || doRadiusProcess || doRadAngProcess || doCoordinatesProcess)) return null;
        this._initCommonDataView();
    }
}

exports.BaseMarkArea = BaseMarkArea, BaseMarkArea.specKey = "markArea";
//# sourceMappingURL=base-mark-area.js.map
