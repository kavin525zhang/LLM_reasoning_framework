"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.judge = exports.judgeFilterTree = void 0;
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const judgeFilterTree = (params) => {
    const { filterNode, item, getValue, } = params;
    switch (filterNode.type) {
        case (types_1.FilterNodeType.And): {
            const valid = filterNode.conditions.every(filterNode => (0, exports.judgeFilterTree)({ filterNode, item, getValue }));
            return filterNode.not ? !valid : valid;
        }
        case (types_1.FilterNodeType.Or): {
            if (!filterNode.conditions.length)
                return true;
            const valid = filterNode.conditions.some(filterNode => (0, exports.judgeFilterTree)({ filterNode, item, getValue }));
            return filterNode.not ? !valid : valid;
        }
        case (types_1.FilterNodeType.Condition): {
            const value = getValue({
                item,
                condition: filterNode,
            });
            const valid = (0, exports.judge)({
                value,
                filter: filterNode,
            });
            return filterNode.not ? !valid : valid;
        }
    }
};
exports.judgeFilterTree = judgeFilterTree;
const judge = ({ value, filter }) => {
    if (value === null) {
        if (filter.operator === types_1.FilterOperator.IsNull)
            return true;
        return false;
    }
    switch (filter.operator) {
        case types_1.FilterOperator.GreaterThan:
            return value > filter.value;
        case types_1.FilterOperator.GreaterOrEqual:
            return value >= filter.value;
        case types_1.FilterOperator.LessThan:
            return value < filter.value;
        case types_1.FilterOperator.LessOrEqual:
            return value <= filter.value;
        case types_1.FilterOperator.Equal:
            return value == filter.value;
        case types_1.FilterOperator.NotEqual:
            return value != filter.value;
        case types_1.FilterOperator.In:
            return (0, utils_1.includes)(filter.value, value);
        case types_1.FilterOperator.NotIn:
            return !(0, utils_1.includes)(filter.value, value);
        case types_1.FilterOperator.IsNull:
            return false;
        case types_1.FilterOperator.IsNotNull:
            return true;
        case types_1.FilterOperator.Between:
            return (filter.value[0] <= value) && (value <= filter.value[1]);
        case types_1.FilterOperator.NotBetween:
            return (value < filter.value[0]) || (value > filter.value[1]);
        case types_1.FilterOperator.Like: {
            const regex = getLikeRegex(filter.value);
            return regex.test(value);
        }
        case types_1.FilterOperator.NotLike: {
            const regex = getLikeRegex(filter.value);
            return !regex.test(value);
        }
    }
    return false;
};
exports.judge = judge;
const getLikeRegex = (like) => {
    if (!likePatternCache.has(like)) {
        const string = escapeRegExp(like);
        const regexString = `^${string.replace(/%/g, '.*?').replace(/_/g, '.')}$`;
        likePatternCache.set(like, new RegExp(regexString));
    }
    return likePatternCache.get(like);
};
const likePatternCache = new Map();
function escapeRegExp(text) {
    return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
