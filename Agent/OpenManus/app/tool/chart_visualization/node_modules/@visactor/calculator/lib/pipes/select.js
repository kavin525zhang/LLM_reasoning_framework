"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getColumnIdentityName = exports.getColumnIdentity = exports.evaluateGroupColumnValue = exports.evaluateRowColumnValue = exports.getSelectColumnName = exports.selectGroup = exports.select = void 0;
const ts_pattern_1 = require("ts-pattern");
const aggregate_1 = require("./aggregate");
const select = ({ select: { columns }, source }) => {
    return tableData => tableData.map(row => Object.fromEntries(columns.map(selectColumn => [
        (0, exports.getSelectColumnName)(selectColumn),
        (0, exports.evaluateRowColumnValue)({
            row,
            source,
            column: selectColumn
        })
    ])));
};
exports.select = select;
const selectGroup = ({ select: { columns }, source }) => {
    return grouped => grouped.map(group => Object.fromEntries(columns.map((selectColumn) => [
        (0, exports.getSelectColumnName)(selectColumn),
        (0, exports.evaluateGroupColumnValue)({
            group,
            source,
            column: selectColumn
        })
    ])));
};
exports.selectGroup = selectGroup;
const getSelectColumnName = (selectColumn) => {
    return (0, ts_pattern_1.match)(selectColumn)
        .with({ alias: ts_pattern_1.P.string }, ({ alias }) => alias)
        .with({ aggregate: ts_pattern_1.P.optional(ts_pattern_1.P.nullish) }, ({ column }) => column)
        .with({ aggregate: { distinct: ts_pattern_1.P.optional(ts_pattern_1.P.nullish) } }, ({ column, aggregate }) => `${(0, aggregate_1.getAggregationName)(aggregate)}(${column})`)
        .with({ aggregate: ts_pattern_1.P.not(ts_pattern_1.P.nullish) }, ({ column, aggregate }) => `${(0, aggregate_1.getAggregationName)(aggregate)}(distinct ${column})`)
        .exhaustive();
};
exports.getSelectColumnName = getSelectColumnName;
const evaluateRowColumnValue = ({ column, row, source }) => {
    return (0, ts_pattern_1.match)(column)
        .with({ column: ts_pattern_1.P.string }, ({ column }) => row[column])
        .with({ column: ts_pattern_1.P.instanceOf(Function) }, ({ column }) => column({ row, source }))
        .exhaustive();
};
exports.evaluateRowColumnValue = evaluateRowColumnValue;
const evaluateGroupColumnValue = ({ column, group, source }) => {
    return (0, ts_pattern_1.match)(column)
        .with({ column: ts_pattern_1.P.string }, ({ column, aggregate }) => (0, aggregate_1.aggregateGroupColumn)({ group, column, aggregate }))
        .with({ aggregate: ts_pattern_1.P.instanceOf(Function) }, ({ aggregate }) => aggregate({ group, source }))
        .with({ column: ts_pattern_1.P.instanceOf(Function) }, ({ column }) => column({ row: group.rows[0], source }))
        .exhaustive();
};
exports.evaluateGroupColumnValue = evaluateGroupColumnValue;
const getColumnIdentity = (column) => (0, ts_pattern_1.match)(column)
    .with({ column: ts_pattern_1.P.any }, ({ column }) => column)
    .with({ aggregate: ts_pattern_1.P.any }, ({ aggregate }) => aggregate)
    .exhaustive();
exports.getColumnIdentity = getColumnIdentity;
const getColumnIdentityName = (column) => {
    const identity = (0, exports.getColumnIdentity)(column);
    return (0, ts_pattern_1.match)(identity)
        .with(ts_pattern_1.P.string, name => name)
        .with(ts_pattern_1.P.instanceOf(Function), evaluate => evaluate.name)
        .exhaustive();
};
exports.getColumnIdentityName = getColumnIdentityName;
