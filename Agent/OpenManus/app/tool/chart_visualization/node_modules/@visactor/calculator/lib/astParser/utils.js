"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRespondField = exports.getOriginalString = exports.detectFieldType = exports.preprocessSQL = exports.mergeMap = exports.replaceNonASCIICharacters = exports.replaceAll = exports.replaceString = exports.checkIsColumnNode = exports.toFirstUpperCase = exports.execPipeline = void 0;
const vutils_1 = require("@visactor/vutils");
const type_1 = require("./type");
const utils_1 = require("../utils");
const execPipeline = (src, pipes, context) => pipes.reduce((pre, pipe) => {
    const result = pipe(pre, context);
    return result;
}, src);
exports.execPipeline = execPipeline;
const toFirstUpperCase = (name = '') => name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
exports.toFirstUpperCase = toFirstUpperCase;
const checkIsColumnNode = (node, columns, fieldInfo) => {
    if (node.type === 'column_ref') {
        return true;
    }
    return false;
};
exports.checkIsColumnNode = checkIsColumnNode;
const replaceString = (str, replaceMap) => {
    if (!(0, vutils_1.isString)(str)) {
        return str;
    }
    if (replaceMap.has(str)) {
        return replaceMap.get(str);
    }
    else {
        const replaceKeys = [...replaceMap.keys()];
        return replaceKeys.reduce((prev, cur) => {
            return (0, exports.replaceAll)(prev, cur, replaceMap.get(cur));
        }, str);
    }
};
exports.replaceString = replaceString;
const replaceAll = (originStr, replaceStr, newStr) => {
    return originStr.split(replaceStr).join(newStr);
};
exports.replaceAll = replaceAll;
function generateRandomString(len) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    let result = '';
    for (let i = 0; i < len; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}
const replaceNonASCIICharacters = (str) => {
    const nonAsciiCharMap = new Map();
    const newStr = str.replace(/([^\x00-\x7F]+)/g, m => {
        let replacement;
        if (nonAsciiCharMap.has(m)) {
            replacement = nonAsciiCharMap.get(m);
        }
        else {
            replacement = generateRandomString(10);
            nonAsciiCharMap.set(m, replacement);
        }
        return replacement;
    });
    const swappedMap = swapMap(nonAsciiCharMap);
    return { validStr: newStr, replaceMap: swappedMap };
};
exports.replaceNonASCIICharacters = replaceNonASCIICharacters;
const swapMap = (map) => {
    const swappedMap = new Map();
    map.forEach((value, key) => {
        swappedMap.set(value, key);
    });
    return swappedMap;
};
const mergeMap = (map1, map2) => {
    map2.forEach((value, key) => {
        map1.set(key, value);
    });
    return map1;
};
exports.mergeMap = mergeMap;
const preprocessSQL = (sql, fieldInfo) => {
    const noNewLine = sql.replace('\n', ' ');
    const reservedMap = {
        KEY: `_KEY_${generateRandomString(10)}_`
    };
    let validSQL = noNewLine;
    const reservedReplaceMap = new Map();
    fieldInfo.forEach(field => {
        const { fieldName } = field;
        let validFieldName = fieldName;
        Object.keys(reservedMap).forEach(reserveWord => {
            if (validFieldName.toUpperCase().includes(reserveWord)) {
                const validWord = reservedMap[reserveWord];
                validFieldName = validFieldName.toUpperCase().replace(new RegExp(reserveWord, 'g'), validWord);
            }
        });
        validSQL = validSQL.replace(new RegExp(fieldName, 'g'), validFieldName);
        if (fieldName !== validFieldName) {
            reservedReplaceMap.set(validFieldName, fieldName);
        }
    });
    const { validStr, replaceMap } = (0, exports.replaceNonASCIICharacters)(validSQL);
    const mergedMap = (0, exports.mergeMap)(replaceMap, reservedReplaceMap);
    return { validStr, replaceMap: mergedMap };
};
exports.preprocessSQL = preprocessSQL;
function validateDate(date) {
    return false;
}
const detectFieldType = (dataset, column) => {
    let fieldType = undefined;
    dataset.every(data => {
        const value = data[column];
        const numberValue = Number(value);
        if (!fieldType) {
            if (!isNaN(numberValue)) {
                if ((0, utils_1.isInteger)(numberValue)) {
                    fieldType = type_1.DataType.INT;
                }
                else {
                    fieldType = type_1.DataType.FLOAT;
                }
            }
            else if (validateDate(value)) {
                fieldType = type_1.DataType.DATE;
            }
            else {
                fieldType = type_1.DataType.STRING;
            }
            return true;
        }
        else {
            if (fieldType == type_1.DataType.DATE && !validateDate(value)) {
                fieldType = type_1.DataType.STRING;
                return false;
            }
            if (fieldType == type_1.DataType.INT) {
                if (isNaN(numberValue)) {
                    fieldType = type_1.DataType.STRING;
                    return false;
                }
                else if (!(0, utils_1.isInteger)(numberValue)) {
                    fieldType = type_1.DataType.FLOAT;
                    return true;
                }
                return true;
            }
            if (fieldType == type_1.DataType.FLOAT) {
                if (isNaN(numberValue)) {
                    fieldType = type_1.DataType.STRING;
                    return false;
                }
                return true;
            }
            if (fieldType == type_1.DataType.STRING) {
                return false;
            }
            return true;
        }
    });
    return {
        fieldName: column,
        type: fieldType,
        role: [type_1.DataType.STRING, type_1.DataType.DATE].includes(fieldType) ? type_1.ROLE.DIMENSION : type_1.ROLE.MEASURE
    };
};
exports.detectFieldType = detectFieldType;
const getOriginalString = (str, replaceMap) => {
    if (!(0, vutils_1.isString)(str)) {
        return str;
    }
    if (replaceMap.has(str)) {
        return replaceMap.get(str);
    }
    else {
        const replaceKeys = [...replaceMap.keys()];
        return replaceKeys.reduce((prev, cur) => {
            return prev.replace(new RegExp(cur, 'g'), replaceMap.get(cur));
        }, str);
    }
};
exports.getOriginalString = getOriginalString;
const parseRespondField = (responseFieldInfo, dataset, replaceMap) => responseFieldInfo.map(field => ({
    ...field,
    ...(0, exports.detectFieldType)(dataset, field.fieldName),
    fieldName: (0, exports.getOriginalString)(field.fieldName, replaceMap)
}));
exports.parseRespondField = parseRespondField;
