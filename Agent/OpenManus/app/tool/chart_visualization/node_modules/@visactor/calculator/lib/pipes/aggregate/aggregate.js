"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeAggregateCache = exports.getAggregateMethod = exports.aggregateTypeMap = exports.getAggregationName = exports.whetherDistinct = exports.extractColumnValues = exports.getAggregateCacheMap = exports.aggregateWithCache = exports.aggregateGroupColumn = void 0;
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const methods_1 = require("./methods");
const aggregateGroupColumn = (params) => {
    const { group, column, aggregate, } = params;
    if (!aggregate) {
        return group.rows[0][column];
    }
    return (0, exports.aggregateWithCache)({
        group,
        column,
        aggregate,
    });
};
exports.aggregateGroupColumn = aggregateGroupColumn;
const aggregateWithCache = (params) => {
    const { group, column, aggregate, } = params;
    const cacheMap = (0, exports.getAggregateCacheMap)({
        column,
        aggregate,
        group,
    });
    const aggregation = (0, exports.getAggregationName)(aggregate);
    if (!cacheMap.has(aggregation)) {
        const aggregateMethod = (0, exports.getAggregateMethod)(aggregate);
        const columnValues = (0, exports.extractColumnValues)({
            group,
            column,
            distinct: aggregate.distinct
        });
        cacheMap.set(aggregation, aggregateMethod({
            column,
            values: columnValues,
        }));
    }
    return cacheMap.get(aggregation);
};
exports.aggregateWithCache = aggregateWithCache;
const getAggregateCacheMap = (params) => {
    const { column, aggregate, group, } = params;
    if (!group.aggregations) {
        group.aggregations = {};
    }
    if (!group.aggregations[column]) {
        group.aggregations[column] = {};
    }
    const aggregationMap = group.aggregations[column];
    if (!aggregationMap[(0, exports.whetherDistinct)(aggregate)]) {
        aggregationMap[(0, exports.whetherDistinct)(aggregate)] = new Map();
    }
    const cacheMap = aggregationMap[(0, exports.whetherDistinct)(aggregate)];
    return cacheMap;
};
exports.getAggregateCacheMap = getAggregateCacheMap;
const extractColumnValues = (params) => {
    const { column, group, distinct, } = params;
    if (!group.columns) {
        group.columns = {};
    }
    if (!group.columns[column]) {
        group.columns[column] = group.rows.map(row => row[column]);
    }
    const values = group.columns[column];
    if (!distinct) {
        return values;
    }
    if (!group.distinctColumns) {
        group.distinctColumns = {};
    }
    if (!group.distinctColumns[column]) {
        const set = new utils_1.OrderedSet(values);
        group.distinctColumns[column] = [...set];
    }
    return group.distinctColumns[column];
};
exports.extractColumnValues = extractColumnValues;
const whetherDistinct = (aggregate) => (aggregate.distinct ? 'distinct' : 'all');
exports.whetherDistinct = whetherDistinct;
const getAggregationName = (aggregate) => {
    const { method } = aggregate;
    if (typeof method === 'function') {
        return method.name;
    }
    return method;
};
exports.getAggregationName = getAggregationName;
exports.aggregateTypeMap = {
    [types_1.AggregateType.Count]: methods_1.count,
    [types_1.AggregateType.Sum]: methods_1.sum,
    [types_1.AggregateType.Avg]: methods_1.avg,
    [types_1.AggregateType.Max]: methods_1.max,
    [types_1.AggregateType.Min]: methods_1.min,
};
const getAggregateMethod = (aggregate) => {
    const { method } = aggregate;
    if (typeof method === 'function') {
        return method;
    }
    return exports.aggregateTypeMap[method];
};
exports.getAggregateMethod = getAggregateMethod;
const removeAggregateCache = (grouped) => grouped.map(group => ({
    by: group.by,
    rows: group.rows,
}));
exports.removeAggregateCache = removeAggregateCache;
