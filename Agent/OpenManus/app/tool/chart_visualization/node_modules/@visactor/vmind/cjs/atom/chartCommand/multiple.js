"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.MultipleChartCommandAtom = void 0;

const vutils_1 = require("@visactor/vutils"), types_1 = require("../../types"), base_1 = require("../base"), text_1 = require("../../utils/text"), prompt_1 = require("./prompt"), field_1 = require("../../utils/field"), common_1 = require("../../utils/common");

class MultipleChartCommandAtom extends base_1.BaseAtom {
    constructor(context, option) {
        super(context, option), this.name = types_1.AtomName.MULTIPLE_CHART_COMMAND, this.isLLMAtom = !0;
    }
    buildDefaultOptions() {
        return Object.assign(Object.assign({}, super.buildDefaultOptions()), {
            useDataTable: !1,
            filterByRule: !0
        });
    }
    buildDefaultContext(context) {
        return (0, vutils_1.merge)({}, {
            commands: []
        }, context);
    }
    shouldRunByContextUpdate(context) {
        return context.datasets !== this.context.datasets;
    }
    runBeforeLLM() {
        return this.ruleList = this.context.datasets.map((dataset => {
            var _a, _b;
            return !!(null === (_a = this.options) || void 0 === _a ? void 0 : _a.filterByRule) && (null === (_b = null == dataset ? void 0 : dataset.dataTable) || void 0 === _b ? void 0 : _b.length) < 2;
        })), this.context;
    }
    getLLMMessages(query) {
        var _a, _b, _c, _d;
        const {datasets: datasets} = this.context, language = null !== (_b = null === (_a = this.options) || void 0 === _a ? void 0 : _a.language) && void 0 !== _b ? _b : (0, 
        text_1.getLanguageOfText)((null === (_c = null == datasets ? void 0 : datasets[0]) || void 0 === _c ? void 0 : _c.text) || (null === (_d = null == datasets ? void 0 : datasets[0]) || void 0 === _d ? void 0 : _d.summary)), addtionContent = this.getHistoryLLMMessages(query);
        return [ {
            role: "system",
            content: (0, prompt_1.getChartCommandPrompt)(language)
        }, {
            role: "user",
            content: JSON.stringify({
                userInput: datasets.filter(((datasets, i) => !this.ruleList[i])).map((dataset => {
                    var _a;
                    const {text: text, summary: summary, fieldInfo: fieldInfo, dataTable: dataTable} = dataset;
                    return {
                        text: text,
                        summary: summary,
                        fieldInfo: fieldInfo.map((info => {
                            var _a;
                            return {
                                fieldName: info.fieldName,
                                type: info.role || (0, field_1.getRoleByFieldType)(info.type),
                                dataLength: (null === (_a = null == dataTable ? void 0 : dataTable.filter((v => (0, 
                                common_1.isValidData)(v[info.fieldName])))) || void 0 === _a ? void 0 : _a.length) || void 0
                            };
                        })),
                        dataTable: (null === (_a = this.options) || void 0 === _a ? void 0 : _a.useDataTable) ? JSON.stringify(dataTable) : void 0
                    };
                }))
            })
        }, ...addtionContent ];
    }
    parseLLMContent(resJson) {
        const {commands: commands = []} = resJson;
        if (!(0, vutils_1.isArray)(commands) || 0 === commands.length) return console.error("Can't generate chart command in this case"), 
        Object.assign(Object.assign({}, this.context), {
            commands: this.context.datasets.map((v => ""))
        });
        const res = [];
        let commandIndex = 0;
        for (let i = 0; i < this.context.datasets.length; i++) {
            this.ruleList[i] ? res.push("") : res.push(commands[commandIndex++]);
        }
        return Object.assign(Object.assign({}, this.context), {
            commands: res
        });
    }
}

exports.MultipleChartCommandAtom = MultipleChartCommandAtom;
//# sourceMappingURL=multiple.js.map