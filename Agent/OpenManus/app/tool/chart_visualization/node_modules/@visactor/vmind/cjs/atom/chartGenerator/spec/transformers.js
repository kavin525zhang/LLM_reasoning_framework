"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.animationCartesianPie = exports.animationCartisianLine = exports.animationCartesianBar = exports.animationScatter = exports.animationOneByOne = exports.scatterAxis = exports.rankingBarLabel = exports.customMark = exports.legend = exports.commonLabel = exports.transposeField = exports.axis = exports.rankingBarAxis = exports.roseAxis = exports.roseField = exports.rankingBarField = exports.cartesianBar = exports.sankeyLink = exports.sankeyLabel = exports.boxPlotStyle = exports.boxPlotField = exports.sankeyField = exports.radarAxis = exports.radarDisplayConf = exports.radarField = exports.wordCloudDisplayConf = exports.dualAxisAxes = exports.dualAxisSeries = exports.waterfallStackLabel = exports.waterfallAxes = exports.waterfallField = exports.funnelField = exports.wordCloudField = exports.scatterField = exports.pieField = exports.cartesianLine = exports.seriesField = exports.colorLine = exports.colorDynamicBar = exports.colorBar = exports.color = exports.sankeyData = exports.sequenceData = exports.wordCloudData = exports.funnelData = exports.arrayData = exports.data = exports.revisedVChartType = exports.getVChartTypeByVmind = exports.llmChartTypeMap = void 0, 
exports.mapDisplayConf = exports.mapField = exports.basemap = exports.basicHeatMapLegend = exports.basicHeatMapAxes = exports.basicHeatMapColor = exports.basicHeatMapRegion = exports.basicHeatMapSeries = exports.registerChart = exports.vennField = exports.vennData = exports.gaugeDisplayConf = exports.gaugeField = exports.treemapDisplayConf = exports.getTreemapData = exports.treemapData = exports.sunburstDisplayConf = exports.sunburstOrTreemapField = exports.getSunburstData = exports.sunburstData = exports.rangeColumnDisplayConf = exports.rangeColumnField = exports.bubbleCirclePackingDisplayConf = exports.bubbleCirclePackingField = exports.bubbleCirclePackingData = exports.indicator = exports.circularProgressStyle = exports.circularProgressField = exports.linearProgressStyle = exports.linearProgressAxes = exports.linearProgressField = exports.liquidStyle = exports.liquidField = exports.theme = exports.displayConfLine = exports.displayConfBar = void 0;

const vchart_1 = require("@visactor/vchart"), constants_1 = require("./constants"), vutils_1 = require("@visactor/vutils"), chart_advisor_1 = require("@visactor/chart-advisor"), field_1 = require("../../../utils/field"), dataTable_1 = require("../../../utils/dataTable"), types_1 = require("../../../types"), const_1 = require("../const"), chartTypeMap = {
    [types_1.ChartType.BarChart.toUpperCase()]: "bar",
    [types_1.ChartType.LineChart.toUpperCase()]: "line",
    [types_1.ChartType.AreaChart.toUpperCase()]: "area",
    [types_1.ChartType.PieChart.toUpperCase()]: "pie",
    [types_1.ChartType.WordCloud.toUpperCase()]: "wordCloud",
    [types_1.ChartType.ScatterPlot.toUpperCase()]: "scatter",
    [types_1.ChartType.DynamicBarChart.toUpperCase()]: "bar",
    [types_1.ChartType.FunnelChart.toUpperCase()]: "funnel",
    [types_1.ChartType.DualAxisChart.toUpperCase()]: "common",
    [types_1.ChartType.RoseChart.toUpperCase()]: "rose",
    [types_1.ChartType.RadarChart.toUpperCase()]: "radar",
    [types_1.ChartType.SankeyChart.toUpperCase()]: "sankey",
    [types_1.ChartType.WaterFallChart.toUpperCase()]: "waterfall",
    [types_1.ChartType.BoxPlot.toUpperCase()]: "boxPlot",
    [types_1.ChartType.LiquidChart.toUpperCase()]: "liquid",
    [types_1.ChartType.LinearProgress.toUpperCase()]: "linearProgress",
    [types_1.ChartType.CircularProgress.toUpperCase()]: "circularProgress",
    [types_1.ChartType.BubbleCirclePacking.toUpperCase()]: "circlePacking",
    [types_1.ChartType.MapChart.toUpperCase()]: "map",
    [types_1.ChartType.RangeColumnChart.toUpperCase()]: "rangeColumn",
    [types_1.ChartType.SunburstChart.toUpperCase()]: "sunburst",
    [types_1.ChartType.TreemapChart.toUpperCase()]: "treemap",
    [types_1.ChartType.Gauge.toUpperCase()]: "gauge",
    [types_1.ChartType.BasicHeatMap.toUpperCase()]: "common",
    [types_1.ChartType.VennChart.toUpperCase()]: "venn"
};

exports.llmChartTypeMap = Object.keys(types_1.ChartType).reduce(((prev, cur) => {
    const value = types_1.ChartType[cur];
    return prev[value.toUpperCase()] = value, prev;
}), {});

const getVChartTypeByVmind = type => chartTypeMap[type];

exports.getVChartTypeByVmind = getVChartTypeByVmind;

const revisedVChartType = context => {
    const {chartType: chartType, spec: spec} = context;
    return spec.type = (0, exports.getVChartTypeByVmind)(chartType), {
        spec: spec
    };
};

exports.revisedVChartType = revisedVChartType;

const data = context => {
    const {dataTable: dataTable, spec: spec} = context;
    return spec.data = {
        id: "data",
        values: (0, dataTable_1.isValidDataTable)(dataTable) ? dataTable.flat(4) : []
    }, {
        spec: spec
    };
};

exports.data = data;

const arrayData = context => {
    const {dataTable: dataTable, spec: spec} = context;
    return spec.data = [ {
        id: "data",
        values: (0, dataTable_1.isValidDataTable)(dataTable) ? dataTable.flat(4) : []
    } ], {
        spec: spec
    };
};

exports.arrayData = arrayData;

const funnelData = context => {
    const {dataTable: dataTable, cell: cell, spec: spec} = context;
    return spec.data = {
        id: "data",
        values: (0, dataTable_1.isValidDataTable)(dataTable) ? dataTable.sort(((a, b) => b[cell.y] - a[cell.y])) : []
    }, {
        spec: spec
    };
};

exports.funnelData = funnelData;

const wordCloudData = context => {
    const {dataTable: dataTable, spec: spec} = context;
    return spec.data = {
        id: "data",
        values: (0, dataTable_1.isValidDataTable)(dataTable) ? dataTable.slice(0, constants_1.WORDCLOUD_NUM_LIMIT) : []
    }, {
        spec: spec
    };
};

exports.wordCloudData = wordCloudData;

const sequenceData = context => {
    const {dataTable: dataTable, cell: cell, totalTime: totalTime, spec: spec} = context, timeField = cell.time, latestData = (0, 
    dataTable_1.isValidDataTable)(dataTable) ? dataTable : [];
    spec.timeField = timeField;
    const timeArray = [], contentMap = {};
    latestData.forEach((element => {
        if (!element[timeField]) return;
        const time = element[timeField].toString();
        timeArray.includes(time) || (timeArray.push(time), contentMap[time] = []), contentMap[time].push(element);
    }));
    const valueField = cell.y;
    for (const time in contentMap) {
        contentMap[time].sort((function(a, b) {
            return b[valueField] - a[valueField];
        }));
    }
    const dataSpecs = Object.keys(contentMap).map((year => ({
        data: [ {
            id: "id",
            values: contentMap[year]
        }, {
            id: "year",
            values: [ {
                year: year
            } ]
        } ]
    })));
    spec.data = dataSpecs.length > 0 ? dataSpecs[0].data : [];
    const duration = totalTime ? totalTime / (dataSpecs.length ? dataSpecs.length : 1) : 1e3;
    return spec.player = {
        type: "continuous",
        orient: "bottom",
        auto: !0,
        loop: !0,
        dx: 0,
        position: "middle",
        interval: duration,
        specs: dataSpecs,
        slider: {
            railStyle: {
                visible: !1,
                height: 6
            },
            trackStyle: {
                visible: !1
            },
            handlerStyle: {
                visible: !1
            }
        },
        controller: {
            backward: {
                style: {
                    visible: !1,
                    size: 12
                }
            },
            forward: {
                style: {
                    visible: !1,
                    size: 12
                }
            },
            start: {
                style: {
                    visible: !1
                },
                order: 1,
                position: "end"
            },
            pause: {
                style: {
                    visible: !1
                }
            }
        }
    }, spec.animationUpdate = {
        bar: [ {
            type: "update",
            options: {
                excludeChannels: [ "x", "y" ]
            },
            duration: duration,
            easing: "linear"
        }, {
            channel: [ "x", "y" ],
            options: {
                excludeChannels: [ "width" ]
            },
            duration: duration,
            easing: "linear"
        } ],
        axis: {
            duration: duration,
            easing: "linear"
        }
    }, {
        spec: spec
    };
};

exports.sequenceData = sequenceData;

const sankeyData = context => {
    const {dataTable: dataTable, cell: cell, spec: spec} = context, {source: source, target: target} = cell, linkData = (0, 
    dataTable_1.isValidDataTable)(dataTable) ? dataTable : [], nodeData = [ ...new Set([ ...linkData.map((item => item[source])), ...linkData.map((item => item[target])) ]) ].map((node => ({
        name: node
    })));
    return spec.data = {
        id: "data",
        values: [ {
            nodes: nodeData,
            links: linkData
        } ]
    }, {
        spec: spec
    };
};

exports.sankeyData = sankeyData;

const color = context => {
    const {colors: colors, spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (colors && colors.length > 0 ? spec.color = colors : spec.color = constants_1.COLOR_THEMES.default), 
    {
        spec: spec
    };
};

exports.color = color;

const colorBar = context => {
    const {colors: colors, spec: spec, chartTheme: chartTheme} = context, colorThemes = constants_1.COLOR_THEMES.default;
    return chartTheme || (colors && colors.length > 0 ? spec.color = colors : spec.color = colorThemes.map((c => ({
        gradient: "linear",
        x0: .01,
        y0: 0,
        x1: .01,
        y1: 1,
        stops: [ {
            offset: 0,
            color: `#${c.split("#")[1]}FF`
        }, {
            offset: 1,
            color: `#${c.split("#")[1]}00`
        } ]
    })))), {
        spec: spec
    };
};

exports.colorBar = colorBar;

const colorDynamicBar = context => {
    const {colors: colors, spec: spec} = context, colorThemes = constants_1.COLOR_THEMES.default;
    return colors && colors.length > 0 ? spec.color = colors : spec.color = colorThemes.map((c => ({
        gradient: "linear",
        x0: 1,
        y0: .01,
        x1: .01,
        y1: .01,
        stops: [ {
            offset: 0,
            color: `#${c.split("#")[1]}FF`
        }, {
            offset: 1,
            color: `#${c.split("#")[1]}00`
        } ]
    }))), {
        spec: spec
    };
};

exports.colorDynamicBar = colorDynamicBar;

const colorLine = context => {
    const {colors: colors, spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (colors && colors.length > 0 ? spec.color = colors : (spec.color = constants_1.LINEAR_COLOR_THEMES.map((c => ({
        gradient: "linear",
        x0: 0,
        y0: .5,
        x1: 1,
        y1: .5,
        stops: [ {
            offset: 0,
            color: c[0]
        }, {
            offset: 1,
            color: c[1]
        } ]
    }))), spec.point = {
        style: {}
    })), {
        spec: spec
    };
};

exports.colorLine = colorLine;

const seriesField = context => {
    const {spec: spec, fieldInfo: fieldInfo, dataTable: dataTable, cell: cell} = context, cellNew = Object.assign({}, cell), {seriesField: seriesField, xField: propsXField} = spec, colorField = (0, 
    vutils_1.isArray)(seriesField) ? seriesField[0] : seriesField, colorFieldInfo = fieldInfo.find((v => v.fieldName === colorField)), xField = (0, 
    vutils_1.isArray)(propsXField) ? propsXField : [ propsXField ];
    if (colorField && (null == colorFieldInfo ? void 0 : colorFieldInfo.role) === types_1.ROLE.DIMENSION && xField) {
        const xMap = new Map;
        dataTable.forEach((row => {
            const xValue = row[xField[0]];
            xMap.has(xValue) ? xMap.get(xValue).push(row[colorField]) : xMap.set(xValue, [ row[colorField] ]);
        }));
        const xValues = Array.from(xMap.keys());
        let isValidColor = !1;
        for (let i = 0; i < xValues.length; i++) {
            const xValue = xValues[i], colorValues = (0, vutils_1.uniqArray)(xMap.get(xValue));
            if ((0, vutils_1.isArray)(colorValues) && colorValues.length > 1) {
                isValidColor = !0;
                break;
            }
        }
        isValidColor || (spec.seriesField = void 0, spec.xField = xField.filter((field => field !== colorField)), 
        cellNew.color = void 0);
    }
    return {
        spec: spec,
        cell: cellNew
    };
};

exports.seriesField = seriesField;

const cartesianLine = context => {
    const {cell: cell, spec: spec, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell);
    if (spec.xField = cell.x, spec.yField = cell.y, cell.color) spec.seriesField = cell.color; else {
        const remainedFields = fieldInfo.filter((({fieldName: fieldName}) => !spec.xField.includes(fieldName) && spec.yField !== fieldName)), colorField = (0, 
        field_1.getFieldByDataType)(remainedFields, [ types_1.DataType.STRING, types_1.DataType.DATE ]);
        colorField && (spec.seriesField = colorField.fieldName, cellNew.color = colorField.fieldName);
    }
    return {
        spec: spec,
        cell: cellNew
    };
};

exports.cartesianLine = cartesianLine;

const pieField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.valueField = cell.angle || cell.value, (cell.color || cell.category) && (spec.categoryField = cell.color || cell.category), 
    {
        spec: spec
    };
};

exports.pieField = pieField;

const scatterField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.xField = cell.x, spec.yField = cell.y, cell.color && (spec.seriesField = cell.color), 
    cell.size && (spec.sizeField = cell.size, spec.size = {
        type: "linear"
    }), {
        spec: spec
    };
};

exports.scatterField = scatterField;

const wordCloudField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.nameField = cell.color, cell.size && (spec.valueField = cell.size), 
    spec.seriesField = spec.nameField, {
        spec: spec
    };
};

exports.wordCloudField = wordCloudField;

const funnelField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.categoryField = cell.color || cell.x, spec.valueField = cell.value || cell.y, 
    {
        spec: spec
    };
};

exports.funnelField = funnelField;

const waterfallField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.xField = cell.x, spec.yField = cell.y, spec.total = {
        type: "end",
        text: "总计"
    }, {
        spec: spec
    };
};

exports.waterfallField = waterfallField;

const waterfallAxes = context => {
    const {spec: spec} = context;
    return spec.axes = [ {
        orient: "left",
        title: {
            visible: !0,
            text: "favorability"
        },
        label: {
            formatMethod: v => v + "%"
        }
    }, {
        orient: "bottom",
        label: {
            visible: !0
        },
        type: "band",
        paddingInner: .4,
        title: {
            visible: !0,
            text: "date"
        }
    } ], {
        spec: spec
    };
};

exports.waterfallAxes = waterfallAxes;

const waterfallStackLabel = context => {
    const {spec: spec} = context;
    return spec.stackLabel = {
        valueType: "absolute",
        formatMethod: text => text + "%"
    }, {
        spec: spec
    };
};

exports.waterfallStackLabel = waterfallStackLabel;

const dualAxisSeries = context => {
    var _a;
    const {cell: cell, spec: spec} = context, {color: color} = cell, dataValues = spec.data.values;
    return spec.series = [ {
        type: "bar",
        id: constants_1.MAIN_SERIES_ID,
        data: {
            id: spec.data.id + "_bar",
            values: color ? dataValues : dataValues.map((d => Object.assign(Object.assign({}, d), {
                [chart_advisor_1.COLOR_FIELD]: cell.y[0]
            })))
        },
        dataIndex: 0,
        label: {
            visible: !0
        },
        xField: cell.x,
        yField: cell.y[0],
        seriesField: color ? (0, vutils_1.isArray)(color) ? color[0] : color : chart_advisor_1.COLOR_FIELD,
        bar: {
            style: {}
        }
    }, {
        type: "line",
        id: constants_1.SUB_SERIES_ID,
        dataIndex: 0,
        data: {
            id: spec.data.id + "_line",
            values: color ? dataValues : dataValues.map((d => Object.assign(Object.assign({}, d), {
                [chart_advisor_1.COLOR_FIELD]: cell.y[1]
            })))
        },
        label: {
            visible: !0
        },
        xField: cell.x,
        yField: cell.y[(null === (_a = cell.y) || void 0 === _a ? void 0 : _a.length) - 1],
        seriesField: color ? (0, vutils_1.isArray)(color) ? color[0] : color : chart_advisor_1.COLOR_FIELD,
        line: {
            style: {}
        },
        point: {
            style: {}
        }
    } ], spec.data = void 0, spec.labelLayout = "region", {
        spec: spec
    };
};

exports.dualAxisSeries = dualAxisSeries;

const dualAxisAxes = context => {
    const {spec: spec} = context;
    return spec.axes = [ {
        id: constants_1.DIMENSION_AXIS_ID,
        type: "band",
        orient: "bottom"
    }, {
        id: constants_1.MEASURE_AXIS_LEFT_ID,
        seriesId: constants_1.MAIN_SERIES_ID,
        type: "linear",
        orient: "left",
        label: {
            style: {}
        }
    }, {
        id: constants_1.MEASURE_AXIS_RIGHT_ID,
        seriesId: constants_1.SUB_SERIES_ID,
        type: "linear",
        orient: "right",
        tick: {
            visible: !1
        },
        grid: {
            visible: !1
        },
        label: {
            style: {}
        }
    } ], {
        spec: spec
    };
};

exports.dualAxisAxes = dualAxisAxes;

const wordCloudDisplayConf = context => {
    const {spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (spec.fontSizeRange = [ 20, 50 ], spec.fontWeightRange = [ 800, 800 ]), 
    {
        spec: spec
    };
};

exports.wordCloudDisplayConf = wordCloudDisplayConf;

const radarField = context => {
    var _a, _b;
    const {cell: cell, spec: spec} = context;
    return (cell.x || cell.angle) && (spec.categoryField = null !== (_a = cell.x) && void 0 !== _a ? _a : cell.angle), 
    (cell.y || cell.value) && (spec.valueField = null !== (_b = cell.y) && void 0 !== _b ? _b : cell.value), 
    cell.color && (spec.seriesField = cell.color), !spec.categoryField && spec.seriesField && (spec.categoryField = spec.seriesField, 
    delete spec.seriesField), {
        spec: spec
    };
};

exports.radarField = radarField;

const radarDisplayConf = context => {
    const {spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (spec.area = {
        visible: !0
    }), {
        spec: spec
    };
};

exports.radarDisplayConf = radarDisplayConf;

const radarAxis = context => {
    const {spec: spec} = context;
    return spec.axes = [ {
        orient: "radius",
        zIndex: 100,
        domainLine: {
            visible: !1
        },
        label: {
            visible: !0,
            space: 0,
            style: {}
        },
        grid: {
            smooth: !1,
            style: {}
        }
    }, {
        orient: "angle",
        zIndex: 50,
        tick: {
            visible: !1
        },
        domainLine: {
            visible: !1
        },
        label: {
            space: 20
        },
        grid: {
            style: {}
        }
    } ], {
        spec: spec
    };
};

exports.radarAxis = radarAxis;

const sankeyField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.sourceField = cell.source, spec.targetField = cell.target, spec.valueField = cell.value, 
    spec.categoryField = "name", spec.nodeKey = datum => datum.name, {
        spec: spec
    };
};

exports.sankeyField = sankeyField;

const boxPlotField = context => {
    const {cell: cell, dataTable: dataTable, spec: spec} = context, {x: x, y: y} = cell, data = (0, 
    dataTable_1.isValidDataTable)(dataTable) ? dataTable : [];
    spec.xField = x, (0, vutils_1.array)(y).sort(((a, b) => {
        var _a, _b, _c, _d;
        return null !== (_d = null !== (_b = null === (_a = data[0]) || void 0 === _a ? void 0 : _a[a]) && void 0 !== _b ? _b : 0 - (null === (_c = data[0]) || void 0 === _c ? void 0 : _c[b])) && void 0 !== _d ? _d : 0;
    }));
    const yFieldsLen = y.length;
    return spec.minField = y[0], spec.q1Field = y[Math.min(1, yFieldsLen - 1)], spec.medianField = y[Math.floor((yFieldsLen - 1) / 2)], 
    spec.q3Field = y[Math.max(0, yFieldsLen - 2)], spec.maxField = y[yFieldsLen - 1], 
    {
        spec: spec
    };
};

exports.boxPlotField = boxPlotField;

const boxPlotStyle = context => {
    const {spec: spec} = context;
    return spec.boxPlot = Object.assign(Object.assign({}, spec.boxPlot), {
        style: {}
    }), {
        spec: spec
    };
};

exports.boxPlotStyle = boxPlotStyle;

const sankeyLabel = context => {
    const {spec: spec} = context;
    return spec.label = {
        visible: !0,
        style: {}
    }, {
        spec: spec
    };
};

exports.sankeyLabel = sankeyLabel;

const sankeyLink = context => {
    const {spec: spec} = context;
    return spec.link = {
        style: {},
        state: {
            hover: {},
            blur: {}
        }
    }, {
        spec: spec
    };
};

exports.sankeyLink = sankeyLink;

const cartesianBar = context => {
    const {cell: cell, fieldInfo: fieldInfo, spec: spec, stackOrPercent: stackOrPercent} = context, cellNew = Object.assign({}, cell), flattenedXField = Array.isArray(cell.x) ? cell.x : [ cell.x ];
    if (cell.color && cell.color.length > 0 && cell.color !== cell.x && flattenedXField.push(cell.color), 
    spec.xField = flattenedXField, spec.yField = cell.y, cell.color) spec.seriesField = cell.color; else {
        const remainedFields = fieldInfo.filter((({fieldName: fieldName}) => !spec.xField.includes(fieldName) && spec.yField !== fieldName)), colorField = (0, 
        field_1.getFieldByDataType)(remainedFields, [ types_1.DataType.STRING, types_1.DataType.DATE ]);
        colorField && (spec.seriesField = colorField.fieldName, spec.xField.push(colorField.fieldName), 
        cellNew.color = colorField.fieldName);
    }
    return spec.xField.length > 1 && stackOrPercent && (spec.xField = [ spec.xField[0] ], 
    spec.stack = !!stackOrPercent, spec.percent = "percent" === stackOrPercent), {
        spec: spec,
        cell: cellNew
    };
};

exports.cartesianBar = cartesianBar;

const rankingBarField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.xField = cell.y, spec.yField = cell.x, cell.color ? spec.seriesField = cell.color : spec.seriesField = spec.yField, 
    spec.direction = "horizontal", {
        spec: spec
    };
};

exports.rankingBarField = rankingBarField;

const roseField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.valueField = cell.radius || cell.angle, cell.color && (spec.categoryField = cell.color, 
    spec.seriesField = cell.color), spec.outerRadius = .8, spec.innerRadius = .2, {
        spec: spec
    };
};

exports.roseField = roseField;

const roseAxis = context => {
    const {spec: spec} = context;
    return spec.axes = [ {
        orient: "angle",
        domainLine: {
            visible: !1
        },
        grid: {
            visible: !1,
            alignWithLabel: !1
        },
        label: {
            visible: !0
        }
    }, {
        orient: "radius",
        grid: {
            visible: !1,
            smooth: !0
        }
    } ], {
        spec: spec
    };
};

exports.roseAxis = roseAxis;

const rankingBarAxis = context => {
    const {spec: spec} = context;
    return spec.axes = [ {
        animation: !0,
        orient: "bottom",
        type: "linear",
        visible: !0,
        title: {
            visible: !1,
            style: {}
        },
        label: {
            style: {}
        },
        grid: {
            visible: !0
        }
    }, {
        animation: !0,
        id: "axis-left",
        orient: "left",
        tick: {
            visible: !1
        },
        title: {
            visible: !1,
            style: {}
        },
        label: {
            style: {}
        },
        type: "band"
    } ], {
        spec: spec
    };
};

exports.rankingBarAxis = rankingBarAxis;

const axis = context => {
    var _a, _b;
    const {spec: spec, cell: cell, fieldInfo: fieldInfo} = context, {y: celly} = cell, yFieldsInfo = ((0, 
    vutils_1.isArray)(celly) ? celly : [ celly ]).map((field => fieldInfo.find((v => v.fieldName === field)))), isAllRatio = yFieldsInfo.every((v => !!(null == v ? void 0 : v.ratioGranularity))), isSameUnit = 1 === (0, 
    vutils_1.uniqArray)(yFieldsInfo.map((v => null == v ? void 0 : v.unit)).filter((v => !!v))).length;
    return spec.axes = [ {
        orient: "bottom",
        type: "band",
        label: {
            style: {}
        },
        title: {
            visible: !1,
            style: {}
        }
    }, {
        orient: "left",
        type: "linear",
        label: {
            style: {},
            formatter: isAllRatio ? "{label:~%}" : void 0
        },
        unit: isSameUnit && ![ "%", "‰" ].includes(null === (_a = yFieldsInfo[0]) || void 0 === _a ? void 0 : _a.unit) ? {
            visible: !0,
            text: null === (_b = yFieldsInfo[0]) || void 0 === _b ? void 0 : _b.unit
        } : void 0,
        title: {
            visible: !1,
            style: {}
        }
    } ], {
        spec: spec
    };
};

exports.axis = axis;

const transposeField = context => {
    const {spec: spec, transpose: transpose} = context;
    if (transpose) {
        const newSpec = Object.assign(Object.assign({}, spec), {
            xField: spec.yField,
            yField: spec.xField,
            direction: "horizontal"
        }), bottomAxis = (newSpec.axes || []).find((axis => "bottom" === axis.orient)), leftAxis = (newSpec.axes || []).find((axis => "left" === axis.orient));
        return bottomAxis && (bottomAxis.orient = "left"), leftAxis && (leftAxis.orient = "bottom"), 
        Object.assign(Object.assign({}, context), {
            spec: newSpec
        });
    }
    return context;
};

exports.transposeField = transposeField;

const commonLabel = context => {
    const {spec: spec, fieldInfo: fieldInfo, cell: cell} = context, {y: celly} = cell;
    if (spec.label = {
        visible: !0
    }, (0, vutils_1.isArray)(celly) && celly.length > 1) ; else if (celly) {
        const field = (0, vutils_1.isArray)(celly) ? celly[0] : celly, info = fieldInfo.find((v => v.fieldName === field));
        (null == info ? void 0 : info.ratioGranularity) && (spec.label.formatter = `{${field}:~%}`);
    }
    return {
        spec: spec
    };
};

exports.commonLabel = commonLabel;

const legend = context => {
    const {cell: cell, spec: spec} = context;
    return cell.color || cell.category || spec.seriesField || "common" === spec.type ? (spec.legends = [ {
        orient: "right",
        type: "discrete",
        item: {
            visible: !0,
            background: {
                style: {}
            },
            label: {
                style: {}
            },
            shape: {
                style: {}
            }
        }
    } ], {
        spec: spec
    }) : {
        spec: spec
    };
};

exports.legend = legend;

const customMark = context => {
    const {spec: spec} = context;
    return spec.customMark = [ {
        type: "text",
        dataId: "year",
        style: {
            textBaseline: "bottom",
            fontSize: 130,
            textAlign: "right",
            fontFamily: "PingFang SC",
            fontWeight: 600,
            text: datum => datum.year,
            x: () => 700,
            y: () => 430,
            fill: "grey",
            fillOpacity: .5
        }
    } ], {
        spec: spec
    };
};

exports.customMark = customMark;

const rankingBarLabel = context => {
    const {spec: spec} = context;
    return spec.label = {
        visible: !0,
        style: {
            fill: "#FFFFFF",
            stroke: null
        },
        animation: {
            duration: spec.animationUpdate.axis.duration,
            easing: "linear"
        }
    }, {
        spec: spec
    };
};

exports.rankingBarLabel = rankingBarLabel;

const scatterAxis = context => {
    const {spec: spec, fieldInfo: fieldInfo} = context, xField = spec.xField, yField = spec.yField, xFieldInfo = fieldInfo.find((field => xField === field.fieldName)), yFieldInfo = fieldInfo.find((field => yField === field.fieldName));
    return spec.axes = [ {
        orient: "bottom",
        type: [ types_1.DataType.DATE, types_1.DataType.STRING ].includes(null == xFieldInfo ? void 0 : xFieldInfo.type) ? "band" : "linear",
        label: {
            style: {}
        },
        title: {
            visible: !1,
            style: {}
        }
    }, {
        orient: "left",
        type: [ types_1.DataType.DATE, types_1.DataType.STRING ].includes(null == yFieldInfo ? void 0 : yFieldInfo.type) ? "band" : "linear",
        label: {
            style: {}
        },
        title: {
            visible: !1,
            style: {}
        }
    } ], {
        spec: spec
    };
};

exports.scatterAxis = scatterAxis;

const oneByOneDelayFunc = delay => datum => datum.__CHARTSPACE_DEFAULT_DATA_INDEX % constants_1.oneByOneGroupSize * delay, animationOneByOne = context => {
    var _a;
    const {spec: spec} = context;
    if ("wordCloud3d" === spec.type) return {
        spec: spec
    };
    const totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : constants_1.DEFAULT_VIDEO_LENGTH_LONG, duration = constants_1.animationDuration, dataLength = spec.data.values.length, delay = Math.max(totalTime / dataLength - duration, 0), finalDuration = 0 === delay ? totalTime / dataLength : duration, finalDelay = 0 === delay ? Number.MIN_VALUE : delay;
    return spec.animationAppear = {
        oneByOne: finalDelay,
        duration: finalDuration
    }, {
        spec: spec
    };
};

exports.animationOneByOne = animationOneByOne;

const animationScatter = context => {
    var _a;
    const {spec: spec} = context, totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : constants_1.DEFAULT_VIDEO_LENGTH, dataLength = spec.data.values.length, delay = totalTime / Math.ceil(dataLength / constants_1.oneByOneGroupSize);
    return spec.animationAppear = {
        duration: constants_1.animationDuration,
        delay: oneByOneDelayFunc(delay)
    }, {
        spec: spec
    };
};

function onlyUnique(value, index, array) {
    return array.indexOf(value) === index;
}

exports.animationScatter = animationScatter;

const animationCartesianBar = context => {
    var _a;
    const {spec: spec} = context, totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : constants_1.DEFAULT_VIDEO_LENGTH, groupKey = Array.isArray(spec.xField) ? spec.xField[0] : spec.xField, groupNum = spec.data.values.map((d => d[groupKey])).filter(onlyUnique).length;
    return spec.animationAppear = {
        oneByOne: Number.MIN_VALUE,
        duration: totalTime / groupNum
    }, {
        spec: spec
    };
};

exports.animationCartesianBar = animationCartesianBar;

const animationCartisianLine = context => {
    var _a;
    const {spec: spec} = context, totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : constants_1.DEFAULT_VIDEO_LENGTH, groupKey = Array.isArray(spec.xField) ? spec.xField[0] : spec.xField, groups = spec.data.values.map((d => d[groupKey])).filter(onlyUnique), lineAnimationTotalTime = totalTime > 2e3 ? 2e3 : totalTime, pointDelay = lineAnimationTotalTime / groups.length;
    return spec.animationAppear = {
        line: {
            type: "clipIn",
            duration: lineAnimationTotalTime,
            easing: "linear"
        },
        point: {
            delay: datum => groups.findIndex((d => d === datum[groupKey])) * pointDelay
        }
    }, spec.animationNormal = {
        point: {
            loop: !0,
            timeSlices: [ {
                effects: {
                    channel: {
                        size: {
                            to: 14
                        }
                    },
                    easing: "circInOut"
                },
                duration: 1e3
            }, {
                effects: {
                    channel: {
                        size: {
                            to: 10
                        }
                    },
                    easing: "circInOut"
                },
                duration: 500
            } ]
        }
    }, {
        spec: spec
    };
};

exports.animationCartisianLine = animationCartisianLine;

const animationCartesianPie = context => {
    var _a;
    const {spec: spec} = context, totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : constants_1.DEFAULT_PIE_VIDEO_LENGTH, groupKey = context.cell.color, groupNum = spec.data.values.map((d => d[groupKey])).filter(onlyUnique).length, loopTime = 100 + 100 * groupNum + 400;
    return 500 * groupNum + loopTime < totalTime ? (spec.animationAppear = {
        oneByOne: Number.MIN_VALUE,
        duration: (totalTime - loopTime) / groupNum,
        options: {
            overall: !1
        }
    }, spec.animationNormal = {
        pie: [ {
            startTime: 100,
            oneByOne: 100,
            timeSlices: [ {
                delay: 0,
                effects: {
                    channel: {
                        scaleX: {
                            to: 1.2
                        },
                        scaleY: {
                            to: 1.2
                        }
                    },
                    easing: "linear"
                },
                duration: 200
            }, {
                effects: {
                    channel: {
                        scaleX: {
                            to: 1
                        },
                        scaleY: {
                            to: 1
                        }
                    },
                    easing: "linear"
                },
                duration: 200
            } ]
        } ]
    }) : spec.animationAppear = {
        oneByOne: Number.MIN_VALUE,
        duration: totalTime / groupNum,
        options: {
            overall: !1
        }
    }, {
        spec: spec
    };
};

exports.animationCartesianPie = animationCartesianPie;

const displayConfBar = context => {
    const {spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (spec.bar = {
        style: {}
    }), {
        spec: spec
    };
};

exports.displayConfBar = displayConfBar;

const displayConfLine = context => {
    const {spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (spec.line = {
        style: {}
    }), {
        spec: spec
    };
};

exports.displayConfLine = displayConfLine;

const theme = context => {
    const {chartTheme: chartTheme, spec: spec} = context;
    return "string" == typeof chartTheme ? Object.keys(const_1.builtinThemeMap).some((key => key === chartTheme && (spec.theme = const_1.builtinThemeMap[chartTheme], 
    !0))) : "object" == typeof chartTheme && (spec.theme = chartTheme), spec.theme && spec.theme.colorScheme && (spec.color = void 0), 
    {
        spec: spec
    };
};

exports.theme = theme;

const liquidField = context => {
    const {cell: cell, dataTable: dataTable, spec: spec} = context;
    return spec.valueField = cell.value, spec.indicatorSmartInvert = !0, {
        spec: spec
    };
};

exports.liquidField = liquidField;

const liquidStyle = context => {
    const {spec: spec} = context;
    return spec.liquid = Object.assign(Object.assign({}, spec.liquid), {
        style: {}
    }), {
        spec: spec
    };
};

exports.liquidStyle = liquidStyle;

const linearProgressField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.xField = cell.y, spec.yField = cell.x, cell.color && (spec.seriesField = cell.color), 
    spec.cornerRadius = 20, {
        spec: spec
    };
};

exports.linearProgressField = linearProgressField;

const linearProgressAxes = context => {
    const {cell: cell, spec: spec} = context, hasSingleData = spec.data.values && 1 === spec.data.values.length;
    return spec.axes = [ {
        orient: "left",
        type: "band",
        domainLine: {
            visible: !1
        },
        tick: {
            visible: !1
        },
        label: {
            formatMethod: hasSingleData ? val => `${cell.x}: ${val}` : null,
            style: {
                fontSize: 16
            }
        }
    }, {
        orient: "bottom",
        type: "linear",
        visible: !0,
        grid: {
            visible: !1
        },
        label: {
            formatMethod: val => val >= 0 && val <= 1 ? 100 * val + "%" : val,
            flush: !0
        }
    } ], {
        spec: spec
    };
};

exports.linearProgressAxes = linearProgressAxes;

const linearProgressStyle = context => {
    const {spec: spec} = context;
    return spec.progress = Object.assign(Object.assign({}, spec.progress), {
        style: {}
    }), {
        spec: spec
    };
};

exports.linearProgressStyle = linearProgressStyle;

const circularProgressField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.categoryField = cell.color, spec.valueField = cell.value, spec.seriesField = cell.color, 
    spec.radius = .8, spec.innerRadius = .7, spec.roundCap = !0, spec.cornerRadius = 20, 
    {
        spec: spec
    };
};

exports.circularProgressField = circularProgressField;

const circularProgressStyle = context => {
    const {spec: spec} = context;
    return spec.progress = Object.assign(Object.assign({}, spec.progress), {
        style: {}
    }), {
        spec: spec
    };
};

exports.circularProgressStyle = circularProgressStyle;

const indicator = context => {
    var _a, _b;
    const {spec: spec, cell: cell} = context, firstEntry = spec.data.values[0];
    if (!firstEntry) return {
        spec: spec
    };
    const valueField = null !== (_a = cell.value) && void 0 !== _a ? _a : cell.y, value = firstEntry[valueField], cat = firstEntry[(0, 
    field_1.getFieldIdInCell)(null !== (_b = cell.radius) && void 0 !== _b ? _b : cell.x)];
    return spec.indicator = {
        visible: !0,
        fixed: !0,
        trigger: "none",
        title: {
            visible: !0,
            autoLimit: !0,
            space: 12,
            style: {
                fontSize: 16,
                fill: "gray",
                text: null != cat ? cat : valueField
            }
        },
        content: [ {
            visible: !0,
            style: {
                fontSize: 20,
                fill: "#000",
                text: `${(100 * value).toFixed(1)}%`
            }
        } ]
    }, {
        spec: spec
    };
};

exports.indicator = indicator;

const bubbleCirclePackingData = context => {
    const {dataTable: dataTable, spec: spec, cell: cell} = context;
    return cell.size && dataTable.forEach((data => {
        data.value = data[cell.size], delete data[cell.size];
    })), {
        spec: spec
    };
};

exports.bubbleCirclePackingData = bubbleCirclePackingData;

const bubbleCirclePackingField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.categoryField = cell.color || cell.x, cell.size && (spec.valueField = cell.size), 
    {
        spec: spec
    };
};

exports.bubbleCirclePackingField = bubbleCirclePackingField;

const bubbleCirclePackingDisplayConf = context => {
    const {spec: spec} = context;
    return spec.drill = !0, spec.layoutPadding = 5, spec.animationEnter = {
        easing: "cubicInOut"
    }, spec.animationExit = {
        easing: "cubicInOut"
    }, spec.animationUpdate = {
        easing: "cubicInOut"
    }, {
        spec: spec
    };
};

exports.bubbleCirclePackingDisplayConf = bubbleCirclePackingDisplayConf;

const rangeColumnField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.yField = cell.x, spec.xField = [ cell.y[0], cell.y[1] ], {
        spec: spec
    };
};

exports.rangeColumnField = rangeColumnField;

const rangeColumnDisplayConf = context => {
    const {spec: spec} = context;
    return spec.direction = "horizontal", spec.label = {
        visible: !0
    }, {
        spec: spec
    };
};

exports.rangeColumnDisplayConf = rangeColumnDisplayConf;

const sunburstData = context => {
    const {dataTable: dataTable, cell: cell, spec: spec} = context;
    return spec.data = {
        id: "data",
        values: (0, exports.getSunburstData)(dataTable, cell.color, 0, cell.size)
    }, {
        spec: spec
    };
};

exports.sunburstData = sunburstData;

const getSunburstData = (dataTable, colorField, index, sizeField) => {
    if (colorField.length - 1 === index) return Array.from(new Set(dataTable.map((data => ({
        name: data[colorField[index]],
        value: data[sizeField]
    })))));
    const values = Array.from(new Set(dataTable.map((data => data[colorField[index]]))));
    return values.map((value => {
        const currentDataset = dataTable.filter((data => data[colorField[index]] === value));
        return {
            name: value,
            children: (0, exports.getSunburstData)(currentDataset, colorField, index + 1, sizeField)
        };
    }));
};

exports.getSunburstData = getSunburstData;

const sunburstOrTreemapField = context => {
    const {spec: spec} = context;
    return spec.categoryField = "name", spec.valueField = "value", {
        spec: spec
    };
};

exports.sunburstOrTreemapField = sunburstOrTreemapField;

const sunburstDisplayConf = context => {
    const {spec: spec} = context;
    return spec.offsetX = 0, spec.offsetY = 0, spec.outerRadius = 1, spec.innerRadius = 0, 
    spec.gap = 5, spec.drill = !0, spec.sunburst = {
        visible: !0,
        style: {
            fillOpacity: datum => datum.isLeaf ? .4 : .8
        }
    }, spec.label = {
        visible: !0,
        style: {
            fontSize: 12,
            fillOpacity: datum => datum.isLeaf ? .4 : .8
        }
    }, spec.tooltip = {
        mark: {
            title: {
                value: val => {
                    var _a;
                    return null === (_a = null == val ? void 0 : val.datum) || void 0 === _a ? void 0 : _a.map((data => data.name)).join(" / ");
                }
            }
        }
    }, spec.animationEnter = {
        easing: "cubicInOut",
        duration: 1e3
    }, spec.animationExit = {
        easing: "cubicInOut",
        duration: 1e3
    }, spec.animationUpdate = {
        easing: "cubicInOut",
        duration: 1e3
    }, {
        spec: spec
    };
};

exports.sunburstDisplayConf = sunburstDisplayConf;

const treemapData = context => {
    const {dataTable: dataTable, cell: cell, spec: spec} = context;
    return spec.data = {
        id: "data",
        values: (0, exports.getTreemapData)(dataTable, (0, vutils_1.isArray)(cell.color) ? cell.color : [ cell.color ], 0, cell.size)
    }, {
        spec: spec
    };
};

exports.treemapData = treemapData;

const getTreemapData = (dataTable, colorField, index, sizeField) => {
    if (colorField.length - 1 === index) return Array.from(new Set(dataTable.map((data => ({
        name: data[colorField[index]],
        value: data[sizeField]
    })))));
    const values = Array.from(new Set(dataTable.map((data => data[colorField[index]]))));
    return values.map((value => {
        const currentDataset = dataTable.filter((data => data[colorField[index]] === value));
        return currentDataset[0] && "" === currentDataset[0][colorField[index + 1]] ? {
            name: value,
            value: currentDataset[0][sizeField]
        } : {
            name: value,
            children: (0, exports.getTreemapData)(currentDataset, colorField, index + 1, sizeField)
        };
    }));
};

exports.getTreemapData = getTreemapData;

const treemapDisplayConf = context => {
    const {spec: spec} = context;
    return spec.label = {
        visible: !0,
        style: {
            fontSize: 12
        }
    }, {
        spec: spec
    };
};

exports.treemapDisplayConf = treemapDisplayConf;

const gaugeField = context => {
    const {spec: spec, cell: cell} = context;
    return spec.valueField = cell.size, spec.categoryField = cell.color, {
        spec: spec
    };
};

exports.gaugeField = gaugeField;

const gaugeDisplayConf = context => {
    const {spec: spec} = context;
    return spec.outerRadius = .8, spec.innerRadius = .5, spec.startAngle = -180, spec.endAngle = 0, 
    {
        spec: spec
    };
};

exports.gaugeDisplayConf = gaugeDisplayConf;

const vennData = context => {
    const {dataTable: dataTable, spec: spec, cell: cell} = context, id2dataMap = {}, setsField = cell.color[0], nameField = cell.color[1];
    return dataTable.forEach((data => {
        id2dataMap[data[setsField]] ? id2dataMap[data[setsField]].sets.push(data[nameField]) : id2dataMap[data[setsField]] = {
            sets: [ data[nameField] ],
            value: data[cell.size]
        };
    })), spec.data = {
        values: Object.values(id2dataMap)
    }, {
        spec: spec
    };
};

exports.vennData = vennData;

const vennField = context => {
    const {spec: spec} = context;
    return spec.valueField = "value", spec.categoryField = "sets", spec.seriesField = "sets", 
    {
        spec: spec
    };
};

exports.vennField = vennField;

const registerChart = context => {
    const {spec: spec} = context;
    return "venn" === spec.type && (0, vchart_1.registerVennChart)(), {
        spec: spec
    };
};

exports.registerChart = registerChart;

const basicHeatMapSeries = context => {
    const {spec: spec, cell: cell} = context;
    return spec.series = [ {
        type: "heatmap",
        regionId: "region0",
        xField: cell.x,
        yField: cell.y,
        valueField: cell.size,
        cell: {
            style: {
                fill: {
                    field: cell.size,
                    scale: "color"
                }
            }
        }
    } ], {
        spec: spec
    };
};

exports.basicHeatMapSeries = basicHeatMapSeries;

const basicHeatMapRegion = context => {
    const {spec: spec} = context;
    return spec.region = [ {
        id: "region0",
        width: 200,
        height: 200,
        padding: {
            top: 40
        }
    } ], {
        spec: spec
    };
};

exports.basicHeatMapRegion = basicHeatMapRegion;

const basicHeatMapColor = context => {
    const {spec: spec, cell: cell} = context;
    return spec.color = {
        type: "linear",
        domain: [ {
            dataId: "data",
            fields: [ cell.size ]
        } ],
        range: constants_1.BASIC_HEAT_MAP_COLOR_THEMES
    }, {
        spec: spec
    };
};

exports.basicHeatMapColor = basicHeatMapColor;

const basicHeatMapAxes = context => {
    const {spec: spec} = context;
    return spec.axes = [ {
        orient: "bottom",
        type: "band",
        grid: {
            visible: !1
        },
        domainLine: {
            visible: !1
        },
        label: {
            space: 10,
            style: {
                textAlign: "left",
                textBaseline: "middle",
                angle: 90,
                fontSize: 8
            }
        },
        bandPadding: 0,
        height: layoutRect => layoutRect.height - 314
    }, {
        orient: "left",
        type: "band",
        grid: {
            visible: !1
        },
        domainLine: {
            visible: !1
        },
        label: {
            space: 10,
            style: {
                fontSize: 8
            }
        },
        bandPadding: 0
    } ], {
        spec: spec
    };
};

exports.basicHeatMapAxes = basicHeatMapAxes;

const basicHeatMapLegend = context => {
    const {spec: spec} = context;
    return spec.legends = {
        visible: !0,
        orient: "right",
        position: "start",
        type: "color",
        field: "value"
    }, {
        spec: spec
    };
};

exports.basicHeatMapLegend = basicHeatMapLegend;

const basemap = context => {
    const {basemapOption: basemapOption, spec: spec} = context;
    return basemapOption.regionProjectType ? spec.region = [ {
        roam: !0,
        projection: {
            type: basemapOption.regionProjectType
        },
        coordinate: basemapOption.regionCoordinate
    } ] : spec.region = [ {
        roam: !0,
        coordinate: basemapOption.regionCoordinate
    } ], spec.map = "map", {
        spec: spec
    };
};

exports.basemap = basemap;

const mapField = context => {
    const {spec: spec, cell: cell} = context;
    return spec.nameField = cell.color, spec.valueField = cell.size, spec.nameProperty = cell.color, 
    {
        spec: spec
    };
};

exports.mapField = mapField;

const mapDisplayConf = context => {
    const {spec: spec, cell: cell} = context;
    return spec.legends = [ {
        visible: !0,
        type: "color",
        field: cell.size,
        orient: "bottom",
        position: "start"
    } ], spec.area = {
        style: {
            fill: {
                field: cell.size,
                scale: "color",
                changeDomain: "replace"
            }
        }
    }, {
        spec: spec
    };
};

exports.mapDisplayConf = mapDisplayConf;
//# sourceMappingURL=transformers.js.map
