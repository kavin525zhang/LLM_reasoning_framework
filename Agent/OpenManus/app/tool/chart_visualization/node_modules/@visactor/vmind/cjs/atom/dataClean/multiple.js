"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.MultipleDataCleanAtom = void 0;

const atom_1 = require("../../types/atom"), base_1 = require("../base"), vutils_1 = require("@visactor/vutils"), utils_1 = require("./utils"), dataClean_1 = require("./dataClean");

class MultipleDataCleanAtom extends base_1.BaseAtom {
    constructor(context, option) {
        super(context, option), this.name = atom_1.AtomName.MULTIPLE_DATA_CLEAN;
    }
    buildDefaultContext(context) {
        return (0, vutils_1.merge)({}, {
            datasets: []
        }, context);
    }
    buildDefaultOptions() {
        return {
            filterSameValueColumn: !0,
            needNumericalFields: !0,
            measureAutoTransfer: !0,
            filterSameDataItem: !0,
            filterRowWithEmptyValues: !0,
            rangeValueTransfer: "last",
            hierarchicalClustering: !0,
            clusterThreshold: .4,
            filterRatioInDataset: .6
        };
    }
    shouldRunByContextUpdate(context) {
        return context.datasets !== this.context.datasets;
    }
    _runWithOutLLM() {
        const {datasets: datasets} = this.context, {filterRatioInDataset: filterRatioInDataset} = this.options, result = [];
        return datasets.forEach((dataset => {
            var _a;
            let newDataset = Object.assign({}, dataset);
            if (dataClean_1.pipelines.forEach((({key: key, func: func}) => {
                const currentOption = "measureAutoTransfer" === key ? null == dataset ? void 0 : dataset.text : this.options[key];
                !1 !== currentOption && (newDataset = Object.assign(Object.assign({}, newDataset), func(newDataset, currentOption)));
            })), this.options.hierarchicalClustering) {
                const {clusterResult: clusterResult = []} = (0, utils_1.getSplitDataViewOfDataTable)(newDataset, this.options.clusterThreshold);
                if (clusterResult.length) {
                    const maxValidCount = clusterResult[0].validCellCount;
                    newDataset = clusterResult.filter((dataView => {
                        const {validCellCount: validCellCount, validMeasureCellCount: validMeasureCellCount, validColumnLength: validColumnLength, validRowLength: validRowLength} = dataView;
                        return validCellCount / maxValidCount >= filterRatioInDataset || validMeasureCellCount === validColumnLength * validRowLength;
                    })).map((dataView => Object.assign(Object.assign({}, newDataset), {
                        dataTable: dataView.dataTable,
                        fieldInfo: dataView.fieldInfo
                    })));
                }
            }
            (0, vutils_1.isArray)(newDataset) && 1 === newDataset.length && (newDataset = newDataset[0]), 
            (0, vutils_1.isArray)(newDataset) ? result.push(...newDataset) : (null === (_a = newDataset.dataTable) || void 0 === _a ? void 0 : _a.length) > 0 && result.push(newDataset);
        })), this.updateContext({
            datasets: result
        }), this.context;
    }
}

exports.MultipleDataCleanAtom = MultipleDataCleanAtom;