{"version":3,"sources":["../src/utils/field.ts"],"names":[],"mappings":"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","file":"field.js","sourcesContent":["import { isArray, uniqArray } from '@visactor/vutils';\nimport type { Cell, DataItem, DataTable, FieldInfo } from '../types';\nimport { DataType, ROLE } from '../types';\nimport { sampleSize, validateDate } from './common';\nimport { isInteger } from '@visactor/calculator';\n\nexport const getRoleByFieldType = (type: DataType) => {\n  if ([DataType.DATE, DataType.TIME, DataType.STRING, DataType.REGION].includes(type)) {\n    return ROLE.DIMENSION;\n  }\n  return ROLE.MEASURE;\n};\n\n/** Format FieldInfo, add role or location attribtuion, it will change fieldInfo directly */\nexport const formatFieldInfo = (fieldInfo: FieldInfo[]) => {\n  fieldInfo.forEach(info => {\n    info.role = getRoleByFieldType(info.type);\n    info.location = getRoleByFieldType(info.type) as any;\n    info.ratioGranularity = info?.type === DataType.RATIO ? info?.ratioGranularity || '%' : null;\n  });\n  return fieldInfo;\n};\n\nexport const getDataListByField = (dataset: DataTable, fieldName: string) => {\n  return uniqArray(dataset.map(d => d[fieldName])) as (string | number)[];\n};\n\nexport const getRemainedFields = (cell: Cell, fieldInfo: FieldInfo[]) => {\n  const usedFields = Object.values(cell).flat();\n  const remainedFields = fieldInfo.filter(f => !usedFields.includes(f.fieldName));\n  return remainedFields;\n};\n\nexport const getFieldByRole = (fields: FieldInfo[], role: ROLE) => {\n  return fields.find(f => f.role === role);\n};\n\nexport const getFieldByDataType = (fields: FieldInfo[], dataTypeList: DataType[]) => {\n  return (fields || []).find(f => dataTypeList.includes(f.type));\n};\nexport const getFieldsByDataType = (fields: FieldInfo[], dataTypeList: DataType[]) => {\n  return fields.filter(f => dataTypeList.includes(f.type));\n};\n\nexport const getFieldDomain = (dataset: DataItem[], column: string, role: ROLE) => {\n  //calculate domain of the column\n  const domain: (string | number)[] = dataset.map(d => (role === ROLE.DIMENSION ? d[column] : Number(d[column])));\n  return role === ROLE.DIMENSION\n    ? (uniqArray(domain) as string[]).slice(0, 20)\n    : [Math.min(...(domain as number[])), Math.max(...(domain as number[]))];\n};\n\nexport const detectFieldType = (dataset: DataItem[], column: string): FieldInfo => {\n  let fieldType: DataType | undefined = ['年份', 'date'].includes(column) ? DataType.DATE : undefined;\n  //detect field type based on rules\n  //The data types have the following inclusion relationships:\n  //date=>string\n  //int=>float=>string\n  //detect field type from strict to loose\n\n  dataset.every(data => {\n    const value = data[column];\n    const numberValue = Number(value);\n    if (!fieldType) {\n      //no accurate fieldType at the beginning, make the first one as fieldType\n      if (!isNaN(numberValue)) {\n        if (isInteger(numberValue)) {\n          fieldType = DataType.INT;\n        } else {\n          fieldType = DataType.FLOAT;\n        }\n      } else if (validateDate(value)) {\n        //check if the value is date\n        fieldType = DataType.DATE;\n      } else {\n        fieldType = DataType.STRING;\n      }\n      return true;\n    }\n    //already has a fieldType, check consistency\n    if (fieldType === DataType.DATE && !validateDate(value)) {\n      //current value is not date, field is string type\n      fieldType = DataType.STRING;\n      return false;\n    }\n    if (fieldType === DataType.INT) {\n      if (isNaN(numberValue)) {\n        //current value is not number, field is string type\n        fieldType = DataType.STRING;\n        return false;\n      } else if (!isInteger(numberValue)) {\n        //current value is not int, convert to float type and continue checking\n        fieldType = DataType.FLOAT;\n        return true;\n      }\n      return true;\n    }\n    if (fieldType === DataType.FLOAT) {\n      if (isNaN(numberValue)) {\n        //current value is not number, field is string type\n        fieldType = DataType.STRING;\n        return false;\n      }\n      return true;\n    }\n    if (fieldType === DataType.STRING) {\n      //no need to detect.\n      return false;\n    }\n    return true;\n  });\n  const role = [DataType.STRING, DataType.DATE].includes(fieldType) ? ROLE.DIMENSION : ROLE.MEASURE;\n  const domain = getFieldDomain(dataset, column, role);\n\n  return {\n    fieldName: column,\n    type: fieldType,\n    role,\n    domain\n  };\n};\nexport const getFieldInfo = (dataset: DataItem[], columns: string[]): FieldInfo[] => {\n  let sampledDataset = dataset;\n  if (dataset.length > 1000) {\n    //sample the dataset if too large\n    sampledDataset = sampleSize(dataset, 1000);\n  }\n  return columns.map(column => detectFieldType(sampledDataset, column));\n};\n\nexport const getFieldInfoFromDataset = (dataset: DataItem[]): FieldInfo[] => {\n  if (!dataset || !dataset.length) {\n    return [];\n  }\n  const columns = new Set();\n  dataset.forEach(data => {\n    const dataKeys = Object.keys(data);\n    dataKeys.forEach(column => {\n      if (!columns.has(column)) {\n        columns.add(column);\n      }\n    });\n  });\n  return getFieldInfo(dataset, Array.from(columns) as string[]);\n};\n\nexport const hasMeasureField = (fieldInfo: FieldInfo[]) => {\n  return fieldInfo.some(f => f.role === ROLE.MEASURE);\n};\n\nexport const getFieldIdInCell = (cellField: any): string => {\n  return isArray(cellField) ? cellField[0] : cellField;\n};\n"]}