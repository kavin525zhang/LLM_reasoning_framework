{"version":3,"sources":["../src/atom/dataClean/multiple.ts"],"names":[],"mappings":"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","file":"multiple.js","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { DatasetFromText, MultipleDataCleanCtx } from '../../types/atom';\nimport { AtomName } from '../../types/atom';\nimport type { MultipleDataCleanOptions } from '../type';\nimport { BaseAtom } from '../base';\nimport { isArray, merge } from '@visactor/vutils';\nimport {\n  canMergeClusterResult,\n  canMergeDataTable,\n  getSplitDataViewOfDataTable,\n  mergeClusterDataView,\n  mergeDataTable\n} from './utils';\nimport { pipelines } from './dataClean';\n\nexport class MultipleDataCleanAtom extends BaseAtom<MultipleDataCleanCtx, MultipleDataCleanOptions> {\n  name = AtomName.MULTIPLE_DATA_CLEAN;\n\n  constructor(context: MultipleDataCleanCtx, option: MultipleDataCleanOptions) {\n    super(context, option);\n  }\n\n  buildDefaultContext(context: MultipleDataCleanCtx): MultipleDataCleanCtx {\n    return merge(\n      {},\n      {\n        datasets: []\n      },\n      context\n    );\n  }\n\n  buildDefaultOptions(): MultipleDataCleanOptions {\n    return {\n      filterSameValueColumn: true,\n      needNumericalFields: true,\n      measureAutoTransfer: true,\n      filterSameDataItem: true,\n      filterRowWithEmptyValues: true,\n      rangeValueTransfer: 'last',\n      hierarchicalClustering: true,\n      clusterThreshold: 0.4,\n      filterRatioInDataset: 0.6\n    };\n  }\n\n  shouldRunByContextUpdate(context: MultipleDataCleanCtx): boolean {\n    return context.datasets !== this.context.datasets;\n  }\n\n  _runWithOutLLM(): MultipleDataCleanCtx {\n    const { datasets } = this.context;\n    const { filterRatioInDataset } = this.options;\n    const result: DatasetFromText[] = [];\n    datasets.forEach(dataset => {\n      let newDataset: any = { ...dataset };\n      pipelines.forEach(({ key, func }) => {\n        const isMeasureAutoTransfer = key === 'measureAutoTransfer';\n        const currentOption = isMeasureAutoTransfer ? dataset?.text : (this.options as any)[key];\n        if (currentOption !== false) {\n          newDataset = {\n            ...newDataset,\n            ...func(newDataset, currentOption)\n          };\n        }\n      });\n      if (this.options.hierarchicalClustering) {\n        const { clusterResult = [] } = getSplitDataViewOfDataTable(newDataset, this.options.clusterThreshold);\n        if (false && canMergeClusterResult(clusterResult)) {\n          /** todo */\n          newDataset = {\n            ...newDataset,\n            ...mergeClusterDataView(clusterResult)\n          };\n        } else if (clusterResult.length) {\n          const maxValidCount = clusterResult[0].validCellCount;\n          newDataset = clusterResult\n            .filter(dataView => {\n              const { validCellCount, validMeasureCellCount, validColumnLength, validRowLength } = dataView;\n              return (\n                validCellCount / maxValidCount >= filterRatioInDataset ||\n                validMeasureCellCount === validColumnLength * validRowLength\n              );\n            })\n            .map(dataView => ({\n              ...newDataset,\n              dataTable: dataView.dataTable,\n              fieldInfo: dataView.fieldInfo\n            }));\n        }\n      }\n      if (isArray(newDataset) && newDataset.length === 1) {\n        newDataset = newDataset[0];\n      }\n      if (isArray(newDataset)) {\n        result.push(...newDataset);\n      }\n      // else if (canMergeDataTable(result[result.length - 1], newDataset)) {\n      //   result[result.length - 1] = mergeDataTable(result[result.length - 1], newDataset);\n      // }\n      else if (newDataset.dataTable?.length > 0) {\n        result.push(newDataset);\n      }\n    });\n    this.updateContext({\n      datasets: result\n    });\n    return this.context;\n  }\n}\n"]}