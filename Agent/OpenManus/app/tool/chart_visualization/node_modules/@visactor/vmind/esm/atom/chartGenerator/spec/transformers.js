import { registerVennChart } from "@visactor/vchart";

import { COLOR_THEMES, DEFAULT_PIE_VIDEO_LENGTH, DEFAULT_VIDEO_LENGTH, DEFAULT_VIDEO_LENGTH_LONG, DIMENSION_AXIS_ID, LINEAR_COLOR_THEMES, MAIN_SERIES_ID, MEASURE_AXIS_LEFT_ID, MEASURE_AXIS_RIGHT_ID, SUB_SERIES_ID, WORDCLOUD_NUM_LIMIT, animationDuration, oneByOneGroupSize, BASIC_HEAT_MAP_COLOR_THEMES } from "./constants";

import { array, isArray, uniqArray } from "@visactor/vutils";

import { COLOR_FIELD } from "@visactor/chart-advisor";

import { getFieldByDataType, getFieldIdInCell } from "../../../utils/field";

import { isValidDataTable } from "../../../utils/dataTable";

import { DataType, ChartType, ROLE } from "../../../types";

import { builtinThemeMap } from "../const";

const chartTypeMap = {
    [ChartType.BarChart.toUpperCase()]: "bar",
    [ChartType.LineChart.toUpperCase()]: "line",
    [ChartType.AreaChart.toUpperCase()]: "area",
    [ChartType.PieChart.toUpperCase()]: "pie",
    [ChartType.WordCloud.toUpperCase()]: "wordCloud",
    [ChartType.ScatterPlot.toUpperCase()]: "scatter",
    [ChartType.DynamicBarChart.toUpperCase()]: "bar",
    [ChartType.FunnelChart.toUpperCase()]: "funnel",
    [ChartType.DualAxisChart.toUpperCase()]: "common",
    [ChartType.RoseChart.toUpperCase()]: "rose",
    [ChartType.RadarChart.toUpperCase()]: "radar",
    [ChartType.SankeyChart.toUpperCase()]: "sankey",
    [ChartType.WaterFallChart.toUpperCase()]: "waterfall",
    [ChartType.BoxPlot.toUpperCase()]: "boxPlot",
    [ChartType.LiquidChart.toUpperCase()]: "liquid",
    [ChartType.LinearProgress.toUpperCase()]: "linearProgress",
    [ChartType.CircularProgress.toUpperCase()]: "circularProgress",
    [ChartType.BubbleCirclePacking.toUpperCase()]: "circlePacking",
    [ChartType.MapChart.toUpperCase()]: "map",
    [ChartType.RangeColumnChart.toUpperCase()]: "rangeColumn",
    [ChartType.SunburstChart.toUpperCase()]: "sunburst",
    [ChartType.TreemapChart.toUpperCase()]: "treemap",
    [ChartType.Gauge.toUpperCase()]: "gauge",
    [ChartType.BasicHeatMap.toUpperCase()]: "common",
    [ChartType.VennChart.toUpperCase()]: "venn"
};

export const llmChartTypeMap = Object.keys(ChartType).reduce(((prev, cur) => {
    const value = ChartType[cur];
    return prev[value.toUpperCase()] = value, prev;
}), {});

export const getVChartTypeByVmind = type => chartTypeMap[type];

export const revisedVChartType = context => {
    const {chartType: chartType, spec: spec} = context;
    return spec.type = chartTypeMap[chartType], {
        spec: spec
    };
};

export const data = context => {
    const {dataTable: dataTable, spec: spec} = context;
    return spec.data = {
        id: "data",
        values: isValidDataTable(dataTable) ? dataTable.flat(4) : []
    }, {
        spec: spec
    };
};

export const arrayData = context => {
    const {dataTable: dataTable, spec: spec} = context;
    return spec.data = [ {
        id: "data",
        values: isValidDataTable(dataTable) ? dataTable.flat(4) : []
    } ], {
        spec: spec
    };
};

export const funnelData = context => {
    const {dataTable: dataTable, cell: cell, spec: spec} = context;
    return spec.data = {
        id: "data",
        values: isValidDataTable(dataTable) ? dataTable.sort(((a, b) => b[cell.y] - a[cell.y])) : []
    }, {
        spec: spec
    };
};

export const wordCloudData = context => {
    const {dataTable: dataTable, spec: spec} = context;
    return spec.data = {
        id: "data",
        values: isValidDataTable(dataTable) ? dataTable.slice(0, WORDCLOUD_NUM_LIMIT) : []
    }, {
        spec: spec
    };
};

export const sequenceData = context => {
    const {dataTable: dataTable, cell: cell, totalTime: totalTime, spec: spec} = context, timeField = cell.time, latestData = isValidDataTable(dataTable) ? dataTable : [];
    spec.timeField = timeField;
    const timeArray = [], contentMap = {};
    latestData.forEach((element => {
        if (!element[timeField]) return;
        const time = element[timeField].toString();
        timeArray.includes(time) || (timeArray.push(time), contentMap[time] = []), contentMap[time].push(element);
    }));
    const valueField = cell.y;
    for (const time in contentMap) {
        contentMap[time].sort((function(a, b) {
            return b[valueField] - a[valueField];
        }));
    }
    const dataSpecs = Object.keys(contentMap).map((year => ({
        data: [ {
            id: "id",
            values: contentMap[year]
        }, {
            id: "year",
            values: [ {
                year: year
            } ]
        } ]
    })));
    spec.data = dataSpecs.length > 0 ? dataSpecs[0].data : [];
    const duration = totalTime ? totalTime / (dataSpecs.length ? dataSpecs.length : 1) : 1e3;
    return spec.player = {
        type: "continuous",
        orient: "bottom",
        auto: !0,
        loop: !0,
        dx: 0,
        position: "middle",
        interval: duration,
        specs: dataSpecs,
        slider: {
            railStyle: {
                visible: !1,
                height: 6
            },
            trackStyle: {
                visible: !1
            },
            handlerStyle: {
                visible: !1
            }
        },
        controller: {
            backward: {
                style: {
                    visible: !1,
                    size: 12
                }
            },
            forward: {
                style: {
                    visible: !1,
                    size: 12
                }
            },
            start: {
                style: {
                    visible: !1
                },
                order: 1,
                position: "end"
            },
            pause: {
                style: {
                    visible: !1
                }
            }
        }
    }, spec.animationUpdate = {
        bar: [ {
            type: "update",
            options: {
                excludeChannels: [ "x", "y" ]
            },
            duration: duration,
            easing: "linear"
        }, {
            channel: [ "x", "y" ],
            options: {
                excludeChannels: [ "width" ]
            },
            duration: duration,
            easing: "linear"
        } ],
        axis: {
            duration: duration,
            easing: "linear"
        }
    }, {
        spec: spec
    };
};

export const sankeyData = context => {
    const {dataTable: dataTable, cell: cell, spec: spec} = context, {source: source, target: target} = cell, linkData = isValidDataTable(dataTable) ? dataTable : [], nodeData = [ ...new Set([ ...linkData.map((item => item[source])), ...linkData.map((item => item[target])) ]) ].map((node => ({
        name: node
    })));
    return spec.data = {
        id: "data",
        values: [ {
            nodes: nodeData,
            links: linkData
        } ]
    }, {
        spec: spec
    };
};

export const color = context => {
    const {colors: colors, spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (colors && colors.length > 0 ? spec.color = colors : spec.color = COLOR_THEMES.default), 
    {
        spec: spec
    };
};

export const colorBar = context => {
    const {colors: colors, spec: spec, chartTheme: chartTheme} = context, colorThemes = COLOR_THEMES.default;
    return chartTheme || (colors && colors.length > 0 ? spec.color = colors : spec.color = colorThemes.map((c => ({
        gradient: "linear",
        x0: .01,
        y0: 0,
        x1: .01,
        y1: 1,
        stops: [ {
            offset: 0,
            color: `#${c.split("#")[1]}FF`
        }, {
            offset: 1,
            color: `#${c.split("#")[1]}00`
        } ]
    })))), {
        spec: spec
    };
};

export const colorDynamicBar = context => {
    const {colors: colors, spec: spec} = context, colorThemes = COLOR_THEMES.default;
    return colors && colors.length > 0 ? spec.color = colors : spec.color = colorThemes.map((c => ({
        gradient: "linear",
        x0: 1,
        y0: .01,
        x1: .01,
        y1: .01,
        stops: [ {
            offset: 0,
            color: `#${c.split("#")[1]}FF`
        }, {
            offset: 1,
            color: `#${c.split("#")[1]}00`
        } ]
    }))), {
        spec: spec
    };
};

export const colorLine = context => {
    const {colors: colors, spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (colors && colors.length > 0 ? spec.color = colors : (spec.color = LINEAR_COLOR_THEMES.map((c => ({
        gradient: "linear",
        x0: 0,
        y0: .5,
        x1: 1,
        y1: .5,
        stops: [ {
            offset: 0,
            color: c[0]
        }, {
            offset: 1,
            color: c[1]
        } ]
    }))), spec.point = {
        style: {}
    })), {
        spec: spec
    };
};

export const seriesField = context => {
    const {spec: spec, fieldInfo: fieldInfo, dataTable: dataTable, cell: cell} = context, cellNew = Object.assign({}, cell), {seriesField: seriesField, xField: propsXField} = spec, colorField = isArray(seriesField) ? seriesField[0] : seriesField, colorFieldInfo = fieldInfo.find((v => v.fieldName === colorField)), xField = isArray(propsXField) ? propsXField : [ propsXField ];
    if (colorField && (null == colorFieldInfo ? void 0 : colorFieldInfo.role) === ROLE.DIMENSION && xField) {
        const xMap = new Map;
        dataTable.forEach((row => {
            const xValue = row[xField[0]];
            xMap.has(xValue) ? xMap.get(xValue).push(row[colorField]) : xMap.set(xValue, [ row[colorField] ]);
        }));
        const xValues = Array.from(xMap.keys());
        let isValidColor = !1;
        for (let i = 0; i < xValues.length; i++) {
            const xValue = xValues[i], colorValues = uniqArray(xMap.get(xValue));
            if (isArray(colorValues) && colorValues.length > 1) {
                isValidColor = !0;
                break;
            }
        }
        isValidColor || (spec.seriesField = void 0, spec.xField = xField.filter((field => field !== colorField)), 
        cellNew.color = void 0);
    }
    return {
        spec: spec,
        cell: cellNew
    };
};

export const cartesianLine = context => {
    const {cell: cell, spec: spec, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell);
    if (spec.xField = cell.x, spec.yField = cell.y, cell.color) spec.seriesField = cell.color; else {
        const remainedFields = fieldInfo.filter((({fieldName: fieldName}) => !spec.xField.includes(fieldName) && spec.yField !== fieldName)), colorField = getFieldByDataType(remainedFields, [ DataType.STRING, DataType.DATE ]);
        colorField && (spec.seriesField = colorField.fieldName, cellNew.color = colorField.fieldName);
    }
    return {
        spec: spec,
        cell: cellNew
    };
};

export const pieField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.valueField = cell.angle || cell.value, (cell.color || cell.category) && (spec.categoryField = cell.color || cell.category), 
    {
        spec: spec
    };
};

export const scatterField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.xField = cell.x, spec.yField = cell.y, cell.color && (spec.seriesField = cell.color), 
    cell.size && (spec.sizeField = cell.size, spec.size = {
        type: "linear"
    }), {
        spec: spec
    };
};

export const wordCloudField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.nameField = cell.color, cell.size && (spec.valueField = cell.size), 
    spec.seriesField = spec.nameField, {
        spec: spec
    };
};

export const funnelField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.categoryField = cell.color || cell.x, spec.valueField = cell.value || cell.y, 
    {
        spec: spec
    };
};

export const waterfallField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.xField = cell.x, spec.yField = cell.y, spec.total = {
        type: "end",
        text: "总计"
    }, {
        spec: spec
    };
};

export const waterfallAxes = context => {
    const {spec: spec} = context;
    return spec.axes = [ {
        orient: "left",
        title: {
            visible: !0,
            text: "favorability"
        },
        label: {
            formatMethod: v => v + "%"
        }
    }, {
        orient: "bottom",
        label: {
            visible: !0
        },
        type: "band",
        paddingInner: .4,
        title: {
            visible: !0,
            text: "date"
        }
    } ], {
        spec: spec
    };
};

export const waterfallStackLabel = context => {
    const {spec: spec} = context;
    return spec.stackLabel = {
        valueType: "absolute",
        formatMethod: text => text + "%"
    }, {
        spec: spec
    };
};

export const dualAxisSeries = context => {
    var _a;
    const {cell: cell, spec: spec} = context, {color: color} = cell, dataValues = spec.data.values;
    return spec.series = [ {
        type: "bar",
        id: MAIN_SERIES_ID,
        data: {
            id: spec.data.id + "_bar",
            values: color ? dataValues : dataValues.map((d => Object.assign(Object.assign({}, d), {
                [COLOR_FIELD]: cell.y[0]
            })))
        },
        dataIndex: 0,
        label: {
            visible: !0
        },
        xField: cell.x,
        yField: cell.y[0],
        seriesField: color ? isArray(color) ? color[0] : color : COLOR_FIELD,
        bar: {
            style: {}
        }
    }, {
        type: "line",
        id: SUB_SERIES_ID,
        dataIndex: 0,
        data: {
            id: spec.data.id + "_line",
            values: color ? dataValues : dataValues.map((d => Object.assign(Object.assign({}, d), {
                [COLOR_FIELD]: cell.y[1]
            })))
        },
        label: {
            visible: !0
        },
        xField: cell.x,
        yField: cell.y[(null === (_a = cell.y) || void 0 === _a ? void 0 : _a.length) - 1],
        seriesField: color ? isArray(color) ? color[0] : color : COLOR_FIELD,
        line: {
            style: {}
        },
        point: {
            style: {}
        }
    } ], spec.data = void 0, spec.labelLayout = "region", {
        spec: spec
    };
};

export const dualAxisAxes = context => {
    const {spec: spec} = context;
    return spec.axes = [ {
        id: DIMENSION_AXIS_ID,
        type: "band",
        orient: "bottom"
    }, {
        id: MEASURE_AXIS_LEFT_ID,
        seriesId: MAIN_SERIES_ID,
        type: "linear",
        orient: "left",
        label: {
            style: {}
        }
    }, {
        id: MEASURE_AXIS_RIGHT_ID,
        seriesId: SUB_SERIES_ID,
        type: "linear",
        orient: "right",
        tick: {
            visible: !1
        },
        grid: {
            visible: !1
        },
        label: {
            style: {}
        }
    } ], {
        spec: spec
    };
};

export const wordCloudDisplayConf = context => {
    const {spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (spec.fontSizeRange = [ 20, 50 ], spec.fontWeightRange = [ 800, 800 ]), 
    {
        spec: spec
    };
};

export const radarField = context => {
    var _a, _b;
    const {cell: cell, spec: spec} = context;
    return (cell.x || cell.angle) && (spec.categoryField = null !== (_a = cell.x) && void 0 !== _a ? _a : cell.angle), 
    (cell.y || cell.value) && (spec.valueField = null !== (_b = cell.y) && void 0 !== _b ? _b : cell.value), 
    cell.color && (spec.seriesField = cell.color), !spec.categoryField && spec.seriesField && (spec.categoryField = spec.seriesField, 
    delete spec.seriesField), {
        spec: spec
    };
};

export const radarDisplayConf = context => {
    const {spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (spec.area = {
        visible: !0
    }), {
        spec: spec
    };
};

export const radarAxis = context => {
    const {spec: spec} = context;
    return spec.axes = [ {
        orient: "radius",
        zIndex: 100,
        domainLine: {
            visible: !1
        },
        label: {
            visible: !0,
            space: 0,
            style: {}
        },
        grid: {
            smooth: !1,
            style: {}
        }
    }, {
        orient: "angle",
        zIndex: 50,
        tick: {
            visible: !1
        },
        domainLine: {
            visible: !1
        },
        label: {
            space: 20
        },
        grid: {
            style: {}
        }
    } ], {
        spec: spec
    };
};

export const sankeyField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.sourceField = cell.source, spec.targetField = cell.target, spec.valueField = cell.value, 
    spec.categoryField = "name", spec.nodeKey = datum => datum.name, {
        spec: spec
    };
};

export const boxPlotField = context => {
    const {cell: cell, dataTable: dataTable, spec: spec} = context, {x: x, y: y} = cell, data = isValidDataTable(dataTable) ? dataTable : [];
    spec.xField = x, array(y).sort(((a, b) => {
        var _a, _b, _c, _d;
        return null !== (_d = null !== (_b = null === (_a = data[0]) || void 0 === _a ? void 0 : _a[a]) && void 0 !== _b ? _b : 0 - (null === (_c = data[0]) || void 0 === _c ? void 0 : _c[b])) && void 0 !== _d ? _d : 0;
    }));
    const yFieldsLen = y.length;
    return spec.minField = y[0], spec.q1Field = y[Math.min(1, yFieldsLen - 1)], spec.medianField = y[Math.floor((yFieldsLen - 1) / 2)], 
    spec.q3Field = y[Math.max(0, yFieldsLen - 2)], spec.maxField = y[yFieldsLen - 1], 
    {
        spec: spec
    };
};

export const boxPlotStyle = context => {
    const {spec: spec} = context;
    return spec.boxPlot = Object.assign(Object.assign({}, spec.boxPlot), {
        style: {}
    }), {
        spec: spec
    };
};

export const sankeyLabel = context => {
    const {spec: spec} = context;
    return spec.label = {
        visible: !0,
        style: {}
    }, {
        spec: spec
    };
};

export const sankeyLink = context => {
    const {spec: spec} = context;
    return spec.link = {
        style: {},
        state: {
            hover: {},
            blur: {}
        }
    }, {
        spec: spec
    };
};

export const cartesianBar = context => {
    const {cell: cell, fieldInfo: fieldInfo, spec: spec, stackOrPercent: stackOrPercent} = context, cellNew = Object.assign({}, cell), flattenedXField = Array.isArray(cell.x) ? cell.x : [ cell.x ];
    if (cell.color && cell.color.length > 0 && cell.color !== cell.x && flattenedXField.push(cell.color), 
    spec.xField = flattenedXField, spec.yField = cell.y, cell.color) spec.seriesField = cell.color; else {
        const remainedFields = fieldInfo.filter((({fieldName: fieldName}) => !spec.xField.includes(fieldName) && spec.yField !== fieldName)), colorField = getFieldByDataType(remainedFields, [ DataType.STRING, DataType.DATE ]);
        colorField && (spec.seriesField = colorField.fieldName, spec.xField.push(colorField.fieldName), 
        cellNew.color = colorField.fieldName);
    }
    return spec.xField.length > 1 && stackOrPercent && (spec.xField = [ spec.xField[0] ], 
    spec.stack = !!stackOrPercent, spec.percent = "percent" === stackOrPercent), {
        spec: spec,
        cell: cellNew
    };
};

export const rankingBarField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.xField = cell.y, spec.yField = cell.x, cell.color ? spec.seriesField = cell.color : spec.seriesField = spec.yField, 
    spec.direction = "horizontal", {
        spec: spec
    };
};

export const roseField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.valueField = cell.radius || cell.angle, cell.color && (spec.categoryField = cell.color, 
    spec.seriesField = cell.color), spec.outerRadius = .8, spec.innerRadius = .2, {
        spec: spec
    };
};

export const roseAxis = context => {
    const {spec: spec} = context;
    return spec.axes = [ {
        orient: "angle",
        domainLine: {
            visible: !1
        },
        grid: {
            visible: !1,
            alignWithLabel: !1
        },
        label: {
            visible: !0
        }
    }, {
        orient: "radius",
        grid: {
            visible: !1,
            smooth: !0
        }
    } ], {
        spec: spec
    };
};

export const rankingBarAxis = context => {
    const {spec: spec} = context;
    return spec.axes = [ {
        animation: !0,
        orient: "bottom",
        type: "linear",
        visible: !0,
        title: {
            visible: !1,
            style: {}
        },
        label: {
            style: {}
        },
        grid: {
            visible: !0
        }
    }, {
        animation: !0,
        id: "axis-left",
        orient: "left",
        tick: {
            visible: !1
        },
        title: {
            visible: !1,
            style: {}
        },
        label: {
            style: {}
        },
        type: "band"
    } ], {
        spec: spec
    };
};

export const axis = context => {
    var _a, _b;
    const {spec: spec, cell: cell, fieldInfo: fieldInfo} = context, {y: celly} = cell, yFieldsInfo = (isArray(celly) ? celly : [ celly ]).map((field => fieldInfo.find((v => v.fieldName === field)))), isAllRatio = yFieldsInfo.every((v => !!(null == v ? void 0 : v.ratioGranularity))), isSameUnit = 1 === uniqArray(yFieldsInfo.map((v => null == v ? void 0 : v.unit)).filter((v => !!v))).length;
    return spec.axes = [ {
        orient: "bottom",
        type: "band",
        label: {
            style: {}
        },
        title: {
            visible: !1,
            style: {}
        }
    }, {
        orient: "left",
        type: "linear",
        label: {
            style: {},
            formatter: isAllRatio ? "{label:~%}" : void 0
        },
        unit: isSameUnit && ![ "%", "‰" ].includes(null === (_a = yFieldsInfo[0]) || void 0 === _a ? void 0 : _a.unit) ? {
            visible: !0,
            text: null === (_b = yFieldsInfo[0]) || void 0 === _b ? void 0 : _b.unit
        } : void 0,
        title: {
            visible: !1,
            style: {}
        }
    } ], {
        spec: spec
    };
};

export const transposeField = context => {
    const {spec: spec, transpose: transpose} = context;
    if (transpose) {
        const newSpec = Object.assign(Object.assign({}, spec), {
            xField: spec.yField,
            yField: spec.xField,
            direction: "horizontal"
        }), bottomAxis = (newSpec.axes || []).find((axis => "bottom" === axis.orient)), leftAxis = (newSpec.axes || []).find((axis => "left" === axis.orient));
        return bottomAxis && (bottomAxis.orient = "left"), leftAxis && (leftAxis.orient = "bottom"), 
        Object.assign(Object.assign({}, context), {
            spec: newSpec
        });
    }
    return context;
};

export const commonLabel = context => {
    const {spec: spec, fieldInfo: fieldInfo, cell: cell} = context, {y: celly} = cell;
    if (spec.label = {
        visible: !0
    }, isArray(celly) && celly.length > 1) ; else if (celly) {
        const field = isArray(celly) ? celly[0] : celly, info = fieldInfo.find((v => v.fieldName === field));
        (null == info ? void 0 : info.ratioGranularity) && (spec.label.formatter = `{${field}:~%}`);
    }
    return {
        spec: spec
    };
};

export const legend = context => {
    const {cell: cell, spec: spec} = context;
    return cell.color || cell.category || spec.seriesField || "common" === spec.type ? (spec.legends = [ {
        orient: "right",
        type: "discrete",
        item: {
            visible: !0,
            background: {
                style: {}
            },
            label: {
                style: {}
            },
            shape: {
                style: {}
            }
        }
    } ], {
        spec: spec
    }) : {
        spec: spec
    };
};

export const customMark = context => {
    const {spec: spec} = context;
    return spec.customMark = [ {
        type: "text",
        dataId: "year",
        style: {
            textBaseline: "bottom",
            fontSize: 130,
            textAlign: "right",
            fontFamily: "PingFang SC",
            fontWeight: 600,
            text: datum => datum.year,
            x: () => 700,
            y: () => 430,
            fill: "grey",
            fillOpacity: .5
        }
    } ], {
        spec: spec
    };
};

export const rankingBarLabel = context => {
    const {spec: spec} = context;
    return spec.label = {
        visible: !0,
        style: {
            fill: "#FFFFFF",
            stroke: null
        },
        animation: {
            duration: spec.animationUpdate.axis.duration,
            easing: "linear"
        }
    }, {
        spec: spec
    };
};

export const scatterAxis = context => {
    const {spec: spec, fieldInfo: fieldInfo} = context, xField = spec.xField, yField = spec.yField, xFieldInfo = fieldInfo.find((field => xField === field.fieldName)), yFieldInfo = fieldInfo.find((field => yField === field.fieldName));
    return spec.axes = [ {
        orient: "bottom",
        type: [ DataType.DATE, DataType.STRING ].includes(null == xFieldInfo ? void 0 : xFieldInfo.type) ? "band" : "linear",
        label: {
            style: {}
        },
        title: {
            visible: !1,
            style: {}
        }
    }, {
        orient: "left",
        type: [ DataType.DATE, DataType.STRING ].includes(null == yFieldInfo ? void 0 : yFieldInfo.type) ? "band" : "linear",
        label: {
            style: {}
        },
        title: {
            visible: !1,
            style: {}
        }
    } ], {
        spec: spec
    };
};

const oneByOneDelayFunc = delay => datum => datum.__CHARTSPACE_DEFAULT_DATA_INDEX % oneByOneGroupSize * delay;

export const animationOneByOne = context => {
    var _a;
    const {spec: spec} = context;
    if ("wordCloud3d" === spec.type) return {
        spec: spec
    };
    const totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : DEFAULT_VIDEO_LENGTH_LONG, duration = animationDuration, dataLength = spec.data.values.length, delay = Math.max(totalTime / dataLength - duration, 0), finalDuration = 0 === delay ? totalTime / dataLength : duration, finalDelay = 0 === delay ? Number.MIN_VALUE : delay;
    return spec.animationAppear = {
        oneByOne: finalDelay,
        duration: finalDuration
    }, {
        spec: spec
    };
};

export const animationScatter = context => {
    var _a;
    const {spec: spec} = context, totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : DEFAULT_VIDEO_LENGTH, dataLength = spec.data.values.length, delay = totalTime / Math.ceil(dataLength / oneByOneGroupSize);
    return spec.animationAppear = {
        duration: animationDuration,
        delay: oneByOneDelayFunc(delay)
    }, {
        spec: spec
    };
};

function onlyUnique(value, index, array) {
    return array.indexOf(value) === index;
}

export const animationCartesianBar = context => {
    var _a;
    const {spec: spec} = context, totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : DEFAULT_VIDEO_LENGTH, groupKey = Array.isArray(spec.xField) ? spec.xField[0] : spec.xField, groupNum = spec.data.values.map((d => d[groupKey])).filter(onlyUnique).length;
    return spec.animationAppear = {
        oneByOne: Number.MIN_VALUE,
        duration: totalTime / groupNum
    }, {
        spec: spec
    };
};

export const animationCartisianLine = context => {
    var _a;
    const {spec: spec} = context, totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : DEFAULT_VIDEO_LENGTH, groupKey = Array.isArray(spec.xField) ? spec.xField[0] : spec.xField, groups = spec.data.values.map((d => d[groupKey])).filter(onlyUnique), lineAnimationTotalTime = totalTime > 2e3 ? 2e3 : totalTime, pointDelay = lineAnimationTotalTime / groups.length;
    return spec.animationAppear = {
        line: {
            type: "clipIn",
            duration: lineAnimationTotalTime,
            easing: "linear"
        },
        point: {
            delay: datum => groups.findIndex((d => d === datum[groupKey])) * pointDelay
        }
    }, spec.animationNormal = {
        point: {
            loop: !0,
            timeSlices: [ {
                effects: {
                    channel: {
                        size: {
                            to: 14
                        }
                    },
                    easing: "circInOut"
                },
                duration: 1e3
            }, {
                effects: {
                    channel: {
                        size: {
                            to: 10
                        }
                    },
                    easing: "circInOut"
                },
                duration: 500
            } ]
        }
    }, {
        spec: spec
    };
};

export const animationCartesianPie = context => {
    var _a;
    const {spec: spec} = context, totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : DEFAULT_PIE_VIDEO_LENGTH, groupKey = context.cell.color, groupNum = spec.data.values.map((d => d[groupKey])).filter(onlyUnique).length, loopTime = 100 + 100 * groupNum + 400;
    return 500 * groupNum + loopTime < totalTime ? (spec.animationAppear = {
        oneByOne: Number.MIN_VALUE,
        duration: (totalTime - loopTime) / groupNum,
        options: {
            overall: !1
        }
    }, spec.animationNormal = {
        pie: [ {
            startTime: 100,
            oneByOne: 100,
            timeSlices: [ {
                delay: 0,
                effects: {
                    channel: {
                        scaleX: {
                            to: 1.2
                        },
                        scaleY: {
                            to: 1.2
                        }
                    },
                    easing: "linear"
                },
                duration: 200
            }, {
                effects: {
                    channel: {
                        scaleX: {
                            to: 1
                        },
                        scaleY: {
                            to: 1
                        }
                    },
                    easing: "linear"
                },
                duration: 200
            } ]
        } ]
    }) : spec.animationAppear = {
        oneByOne: Number.MIN_VALUE,
        duration: totalTime / groupNum,
        options: {
            overall: !1
        }
    }, {
        spec: spec
    };
};

export const displayConfBar = context => {
    const {spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (spec.bar = {
        style: {}
    }), {
        spec: spec
    };
};

export const displayConfLine = context => {
    const {spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (spec.line = {
        style: {}
    }), {
        spec: spec
    };
};

export const theme = context => {
    const {chartTheme: chartTheme, spec: spec} = context;
    return "string" == typeof chartTheme ? Object.keys(builtinThemeMap).some((key => key === chartTheme && (spec.theme = builtinThemeMap[chartTheme], 
    !0))) : "object" == typeof chartTheme && (spec.theme = chartTheme), spec.theme && spec.theme.colorScheme && (spec.color = void 0), 
    {
        spec: spec
    };
};

export const liquidField = context => {
    const {cell: cell, dataTable: dataTable, spec: spec} = context;
    return spec.valueField = cell.value, spec.indicatorSmartInvert = !0, {
        spec: spec
    };
};

export const liquidStyle = context => {
    const {spec: spec} = context;
    return spec.liquid = Object.assign(Object.assign({}, spec.liquid), {
        style: {}
    }), {
        spec: spec
    };
};

export const linearProgressField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.xField = cell.y, spec.yField = cell.x, cell.color && (spec.seriesField = cell.color), 
    spec.cornerRadius = 20, {
        spec: spec
    };
};

export const linearProgressAxes = context => {
    const {cell: cell, spec: spec} = context, hasSingleData = spec.data.values && 1 === spec.data.values.length;
    return spec.axes = [ {
        orient: "left",
        type: "band",
        domainLine: {
            visible: !1
        },
        tick: {
            visible: !1
        },
        label: {
            formatMethod: hasSingleData ? val => `${cell.x}: ${val}` : null,
            style: {
                fontSize: 16
            }
        }
    }, {
        orient: "bottom",
        type: "linear",
        visible: !0,
        grid: {
            visible: !1
        },
        label: {
            formatMethod: val => val >= 0 && val <= 1 ? 100 * val + "%" : val,
            flush: !0
        }
    } ], {
        spec: spec
    };
};

export const linearProgressStyle = context => {
    const {spec: spec} = context;
    return spec.progress = Object.assign(Object.assign({}, spec.progress), {
        style: {}
    }), {
        spec: spec
    };
};

export const circularProgressField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.categoryField = cell.color, spec.valueField = cell.value, spec.seriesField = cell.color, 
    spec.radius = .8, spec.innerRadius = .7, spec.roundCap = !0, spec.cornerRadius = 20, 
    {
        spec: spec
    };
};

export const circularProgressStyle = context => {
    const {spec: spec} = context;
    return spec.progress = Object.assign(Object.assign({}, spec.progress), {
        style: {}
    }), {
        spec: spec
    };
};

export const indicator = context => {
    var _a, _b;
    const {spec: spec, cell: cell} = context, firstEntry = spec.data.values[0];
    if (!firstEntry) return {
        spec: spec
    };
    const valueField = null !== (_a = cell.value) && void 0 !== _a ? _a : cell.y, value = firstEntry[valueField], cat = firstEntry[getFieldIdInCell(null !== (_b = cell.radius) && void 0 !== _b ? _b : cell.x)];
    return spec.indicator = {
        visible: !0,
        fixed: !0,
        trigger: "none",
        title: {
            visible: !0,
            autoLimit: !0,
            space: 12,
            style: {
                fontSize: 16,
                fill: "gray",
                text: null != cat ? cat : valueField
            }
        },
        content: [ {
            visible: !0,
            style: {
                fontSize: 20,
                fill: "#000",
                text: `${(100 * value).toFixed(1)}%`
            }
        } ]
    }, {
        spec: spec
    };
};

export const bubbleCirclePackingData = context => {
    const {dataTable: dataTable, spec: spec, cell: cell} = context;
    return cell.size && dataTable.forEach((data => {
        data.value = data[cell.size], delete data[cell.size];
    })), {
        spec: spec
    };
};

export const bubbleCirclePackingField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.categoryField = cell.color || cell.x, cell.size && (spec.valueField = cell.size), 
    {
        spec: spec
    };
};

export const bubbleCirclePackingDisplayConf = context => {
    const {spec: spec} = context;
    return spec.drill = !0, spec.layoutPadding = 5, spec.animationEnter = {
        easing: "cubicInOut"
    }, spec.animationExit = {
        easing: "cubicInOut"
    }, spec.animationUpdate = {
        easing: "cubicInOut"
    }, {
        spec: spec
    };
};

export const rangeColumnField = context => {
    const {cell: cell, spec: spec} = context;
    return spec.yField = cell.x, spec.xField = [ cell.y[0], cell.y[1] ], {
        spec: spec
    };
};

export const rangeColumnDisplayConf = context => {
    const {spec: spec} = context;
    return spec.direction = "horizontal", spec.label = {
        visible: !0
    }, {
        spec: spec
    };
};

export const sunburstData = context => {
    const {dataTable: dataTable, cell: cell, spec: spec} = context;
    return spec.data = {
        id: "data",
        values: getSunburstData(dataTable, cell.color, 0, cell.size)
    }, {
        spec: spec
    };
};

export const getSunburstData = (dataTable, colorField, index, sizeField) => {
    if (colorField.length - 1 === index) return Array.from(new Set(dataTable.map((data => ({
        name: data[colorField[index]],
        value: data[sizeField]
    })))));
    const values = Array.from(new Set(dataTable.map((data => data[colorField[index]]))));
    return values.map((value => {
        const currentDataset = dataTable.filter((data => data[colorField[index]] === value));
        return {
            name: value,
            children: getSunburstData(currentDataset, colorField, index + 1, sizeField)
        };
    }));
};

export const sunburstOrTreemapField = context => {
    const {spec: spec} = context;
    return spec.categoryField = "name", spec.valueField = "value", {
        spec: spec
    };
};

export const sunburstDisplayConf = context => {
    const {spec: spec} = context;
    return spec.offsetX = 0, spec.offsetY = 0, spec.outerRadius = 1, spec.innerRadius = 0, 
    spec.gap = 5, spec.drill = !0, spec.sunburst = {
        visible: !0,
        style: {
            fillOpacity: datum => datum.isLeaf ? .4 : .8
        }
    }, spec.label = {
        visible: !0,
        style: {
            fontSize: 12,
            fillOpacity: datum => datum.isLeaf ? .4 : .8
        }
    }, spec.tooltip = {
        mark: {
            title: {
                value: val => {
                    var _a;
                    return null === (_a = null == val ? void 0 : val.datum) || void 0 === _a ? void 0 : _a.map((data => data.name)).join(" / ");
                }
            }
        }
    }, spec.animationEnter = {
        easing: "cubicInOut",
        duration: 1e3
    }, spec.animationExit = {
        easing: "cubicInOut",
        duration: 1e3
    }, spec.animationUpdate = {
        easing: "cubicInOut",
        duration: 1e3
    }, {
        spec: spec
    };
};

export const treemapData = context => {
    const {dataTable: dataTable, cell: cell, spec: spec} = context;
    return spec.data = {
        id: "data",
        values: getTreemapData(dataTable, isArray(cell.color) ? cell.color : [ cell.color ], 0, cell.size)
    }, {
        spec: spec
    };
};

export const getTreemapData = (dataTable, colorField, index, sizeField) => {
    if (colorField.length - 1 === index) return Array.from(new Set(dataTable.map((data => ({
        name: data[colorField[index]],
        value: data[sizeField]
    })))));
    const values = Array.from(new Set(dataTable.map((data => data[colorField[index]]))));
    return values.map((value => {
        const currentDataset = dataTable.filter((data => data[colorField[index]] === value));
        return currentDataset[0] && "" === currentDataset[0][colorField[index + 1]] ? {
            name: value,
            value: currentDataset[0][sizeField]
        } : {
            name: value,
            children: getTreemapData(currentDataset, colorField, index + 1, sizeField)
        };
    }));
};

export const treemapDisplayConf = context => {
    const {spec: spec} = context;
    return spec.label = {
        visible: !0,
        style: {
            fontSize: 12
        }
    }, {
        spec: spec
    };
};

export const gaugeField = context => {
    const {spec: spec, cell: cell} = context;
    return spec.valueField = cell.size, spec.categoryField = cell.color, {
        spec: spec
    };
};

export const gaugeDisplayConf = context => {
    const {spec: spec} = context;
    return spec.outerRadius = .8, spec.innerRadius = .5, spec.startAngle = -180, spec.endAngle = 0, 
    {
        spec: spec
    };
};

export const vennData = context => {
    const {dataTable: dataTable, spec: spec, cell: cell} = context, id2dataMap = {}, setsField = cell.color[0], nameField = cell.color[1];
    return dataTable.forEach((data => {
        id2dataMap[data[setsField]] ? id2dataMap[data[setsField]].sets.push(data[nameField]) : id2dataMap[data[setsField]] = {
            sets: [ data[nameField] ],
            value: data[cell.size]
        };
    })), spec.data = {
        values: Object.values(id2dataMap)
    }, {
        spec: spec
    };
};

export const vennField = context => {
    const {spec: spec} = context;
    return spec.valueField = "value", spec.categoryField = "sets", spec.seriesField = "sets", 
    {
        spec: spec
    };
};

export const registerChart = context => {
    const {spec: spec} = context;
    return "venn" === spec.type && registerVennChart(), {
        spec: spec
    };
};

export const basicHeatMapSeries = context => {
    const {spec: spec, cell: cell} = context;
    return spec.series = [ {
        type: "heatmap",
        regionId: "region0",
        xField: cell.x,
        yField: cell.y,
        valueField: cell.size,
        cell: {
            style: {
                fill: {
                    field: cell.size,
                    scale: "color"
                }
            }
        }
    } ], {
        spec: spec
    };
};

export const basicHeatMapRegion = context => {
    const {spec: spec} = context;
    return spec.region = [ {
        id: "region0",
        width: 200,
        height: 200,
        padding: {
            top: 40
        }
    } ], {
        spec: spec
    };
};

export const basicHeatMapColor = context => {
    const {spec: spec, cell: cell} = context;
    return spec.color = {
        type: "linear",
        domain: [ {
            dataId: "data",
            fields: [ cell.size ]
        } ],
        range: BASIC_HEAT_MAP_COLOR_THEMES
    }, {
        spec: spec
    };
};

export const basicHeatMapAxes = context => {
    const {spec: spec} = context;
    return spec.axes = [ {
        orient: "bottom",
        type: "band",
        grid: {
            visible: !1
        },
        domainLine: {
            visible: !1
        },
        label: {
            space: 10,
            style: {
                textAlign: "left",
                textBaseline: "middle",
                angle: 90,
                fontSize: 8
            }
        },
        bandPadding: 0,
        height: layoutRect => layoutRect.height - 314
    }, {
        orient: "left",
        type: "band",
        grid: {
            visible: !1
        },
        domainLine: {
            visible: !1
        },
        label: {
            space: 10,
            style: {
                fontSize: 8
            }
        },
        bandPadding: 0
    } ], {
        spec: spec
    };
};

export const basicHeatMapLegend = context => {
    const {spec: spec} = context;
    return spec.legends = {
        visible: !0,
        orient: "right",
        position: "start",
        type: "color",
        field: "value"
    }, {
        spec: spec
    };
};

export const basemap = context => {
    const {basemapOption: basemapOption, spec: spec} = context;
    return basemapOption.regionProjectType ? spec.region = [ {
        roam: !0,
        projection: {
            type: basemapOption.regionProjectType
        },
        coordinate: basemapOption.regionCoordinate
    } ] : spec.region = [ {
        roam: !0,
        coordinate: basemapOption.regionCoordinate
    } ], spec.map = "map", {
        spec: spec
    };
};

export const mapField = context => {
    const {spec: spec, cell: cell} = context;
    return spec.nameField = cell.color, spec.valueField = cell.size, spec.nameProperty = cell.color, 
    {
        spec: spec
    };
};

export const mapDisplayConf = context => {
    const {spec: spec, cell: cell} = context;
    return spec.legends = [ {
        visible: !0,
        type: "color",
        field: cell.size,
        orient: "bottom",
        position: "start"
    } ], spec.area = {
        style: {
            fill: {
                field: cell.size,
                scale: "color",
                changeDomain: "replace"
            }
        }
    }, {
        spec: spec
    };
};
//# sourceMappingURL=transformers.js.map
