import type { ClusterDataView, DatasetFromText } from '../../types/atom';
import type { DataItem, DataTable } from '../../types';
import { type DataCleanCtx, type FieldInfo } from '../../types';
import type { RangeValueTransferType } from '../type';
export declare const transferFieldInfo: (context: DataCleanCtx, fieldMapping?: Record<string, FieldInfo>) => DataCleanCtx;
export declare const getCtxByfilterSameValueColumn: (context: DataCleanCtx) => DataCleanCtx;
export declare const getCtxByneedNumericalFields: (context: DataCleanCtx) => DataCleanCtx;
export declare const sortDataTableByDate: (context: DataCleanCtx) => DataCleanCtx;
export declare const getCtxBymeasureAutoTransfer: (context: DataCleanCtx, text?: string) => DataCleanCtx;
export declare const getCtxByfilterSameDataItem: (context: DataCleanCtx) => {
    dataTable: any;
    fieldInfo?: FieldInfo[];
    clusterResult?: ClusterDataView[];
    originalDataTable?: DataTable;
    logId?: string;
    id?: string;
    query?: string;
    response?: string;
    error?: string;
    usage?: import("../../types").Usage;
    thoughts?: string;
    toolRes?: any;
};
export declare const getCtxByFilterRowWithNonEmptyValues: (context: DataCleanCtx) => {
    dataTable: DataItem[];
    fieldInfo?: FieldInfo[];
    clusterResult?: ClusterDataView[];
    originalDataTable?: DataTable;
    logId?: string;
    id?: string;
    query?: string;
    response?: string;
    error?: string;
    usage?: import("../../types").Usage;
    thoughts?: string;
    toolRes?: any;
};
export declare const getCtxByRangeValueTranser: (context: DataCleanCtx, type: RangeValueTransferType) => {
    dataTable: {
        [x: string]: import("../../types").DataCell;
    }[];
    fieldInfo?: FieldInfo[];
    clusterResult?: ClusterDataView[];
    originalDataTable?: DataTable;
    logId?: string;
    id?: string;
    query?: string;
    response?: string;
    error?: string;
    usage?: import("../../types").Usage;
    thoughts?: string;
    toolRes?: any;
};
export declare const revisedUnMatchedFieldInfo: (context: DataCleanCtx) => DataCleanCtx;
export declare const getCtxByValidColumnRatio: (context: DataCleanCtx, ratio?: number) => DataCleanCtx;
export declare const canMergeDataTable: (ctxA: DatasetFromText, ctxB: DatasetFromText) => boolean;
export declare const getSplitDataViewOfDataTable: (context: DataCleanCtx, threshold?: number) => DataCleanCtx | {
    originDataTable: DataTable;
    fieldInfo: FieldInfo[];
    dataTable: DataTable;
    clusterResult: ClusterDataView[];
    originalDataTable?: DataTable;
    logId?: string;
    id?: string;
    query?: string;
    response?: string;
    error?: string;
    usage?: import("../../types").Usage;
    thoughts?: string;
    toolRes?: any;
};
export declare const canMergeClusterResult: (clusterResult: ClusterDataView[]) => boolean;
export declare const mergeClusterDataView: (clusterResult: ClusterDataView[]) => {
    fieldInfo: FieldInfo[];
    dataTable: DataTable;
};
export declare const mergeDataTable: (ctxA: DatasetFromText, ctxB: DatasetFromText) => {
    dataTable: {
        [x: string]: import("../../types").DataCell;
    }[];
    fieldInfo: FieldInfo[];
    summary: string;
    textRange: any;
};
