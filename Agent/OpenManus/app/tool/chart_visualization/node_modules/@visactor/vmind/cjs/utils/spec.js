"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.fillSpecTemplateWithData = exports.revisedCell = exports.getCellFromSpec = exports.getFieldMappingFromSpec = exports.getDatasetFromSpec = exports.getChartTypeFromSpec = void 0;

const vutils_1 = require("@visactor/vutils"), types_1 = require("../types"), field_1 = require("./field"), chart_advisor_1 = require("@visactor/chart-advisor"), transformers_1 = require("../atom/chartGenerator/spec/transformers"), dataTable_1 = require("./dataTable"), getChartTypeFromSpec = (spec, vchartType) => {
    if (!spec) return;
    const type = null != vchartType ? vchartType : null == spec ? void 0 : spec.type;
    if ("bar" === type) return types_1.ChartType.BarChart;
    if ("line" === type) return types_1.ChartType.LineChart;
    if ("area" === type) return types_1.ChartType.AreaChart;
    if ("pie" === type) return types_1.ChartType.PieChart;
    if ("wordCloud" === type) return types_1.ChartType.WordCloud;
    if ("scatter" === type) return types_1.ChartType.ScatterPlot;
    if ("funnel" === type) return types_1.ChartType.FunnelChart;
    if ("rose" === type) return types_1.ChartType.RoseChart;
    if ("radar" === type) return types_1.ChartType.RadarChart;
    if ("sankey" === type) return types_1.ChartType.SankeyChart;
    if ("waterfall" === type) return types_1.ChartType.WaterFallChart;
    if ("boxPlot" === type) return types_1.ChartType.BoxPlot;
    if ("common" === type) {
        const {series: series} = spec;
        if (1 === (0, vutils_1.uniqArray)(series.map((s => s.type))).length) return (0, 
        exports.getChartTypeFromSpec)(series[0], vchartType);
        if (series.length > 1 && series.every((s => "bar" === s.type || "line" === s.type || "area" === s.type))) return types_1.ChartType.DualAxisChart;
    }
};

exports.getChartTypeFromSpec = getChartTypeFromSpec;

const getDatasetFromSpec = spec => {
    if (!spec) return [];
    return (0, vutils_1.array)(spec.data).map((d => d.values)).flat(2);
};

exports.getDatasetFromSpec = getDatasetFromSpec;

const getFieldMappingFromSpec = spec => {
    if (!spec) return {};
    let res = {};
    return (0, vutils_1.array)(spec.data).forEach((d => {
        (null == d ? void 0 : d.fields) && (res = (0, vutils_1.merge)(res, d.fields));
    })), res;
};

exports.getFieldMappingFromSpec = getFieldMappingFromSpec;

const getCellFromSpec = (spec, vmindChartType) => {
    var _a, _b, _c, _d;
    if (!spec) return {};
    const {type: type, direction: direction} = spec, isTransposed = "horizontal" === direction;
    if ("bar" === type && spec.player) {
        return {
            time: spec.timeField,
            x: spec.yField,
            y: spec.xField,
            color: spec.seriesField,
            isTransposed: isTransposed
        };
    }
    if ([ "bar", "line", "area" ].includes(type)) {
        return {
            x: spec.xField,
            y: spec.yField,
            color: spec.seriesField,
            isTransposed: isTransposed
        };
    }
    if ("radar" === type) return {
        x: spec.categoryField,
        y: spec.valueField,
        color: spec.seriesField
    };
    if ([ "pie", "rose" ].includes(type)) return {
        x: spec.categoryField,
        y: spec.valueField,
        color: spec.categoryField,
        angle: spec.valueField
    };
    if ("scatter" === type) return {
        color: spec.seriesField,
        size: spec.sizeField,
        x: spec.xField,
        y: spec.yField
    };
    if ("boxPlot" === type) return {
        x: spec.xField,
        y: [ spec.minField, spec.q1Field, spec.medianField, spec.q3Field, spec.maxField ].filter(Boolean)
    };
    if ("common" === type) {
        if ([ types_1.ChartType.BarChart, types_1.ChartType.AreaChart, types_1.ChartType.LineChart ].includes(vmindChartType)) return {
            x: (0, vutils_1.uniqArray)(spec.series.map((s => s.xField)).filter((xField => !!xField)).flat()),
            y: (0, vutils_1.uniqArray)(spec.series.map((s => s.yField)).filter((yField => !!yField)).flat()),
            color: spec.series[0].seriesField,
            isTransposed: isTransposed || spec.series.every((s => "horizontal" === s.direction))
        };
        const series = null !== (_a = spec.series) && void 0 !== _a ? _a : [];
        if (vmindChartType === types_1.ChartType.DualAxisChart) {
            const seriesField = (0, vutils_1.uniqArray)(series.map((s => null == s ? void 0 : s.seriesField)).filter((v => !!v)));
            return {
                x: null === (_b = series[0]) || void 0 === _b ? void 0 : _b.xField,
                y: (0, vutils_1.uniqArray)([ null === (_c = series[0]) || void 0 === _c ? void 0 : _c.yField, null === (_d = series[1]) || void 0 === _d ? void 0 : _d.yField ].filter(Boolean)),
                color: 1 === (null == seriesField ? void 0 : seriesField.length) ? seriesField[0] : void 0,
                isTransposed: isTransposed
            };
        }
        return (0, exports.getCellFromSpec)(series[0], vmindChartType);
    }
    return "wordCloud" === type ? {
        color: spec.nameField,
        size: spec.valueField
    } : "funnel" === type ? {
        x: spec.categoryField,
        y: spec.valueField
    } : "waterfall" === type ? {
        x: spec.xField,
        y: spec.yField,
        color: null == spec ? void 0 : spec.seriesField
    } : "sankey" === type ? {
        source: spec.sourceField,
        target: spec.targetField,
        value: spec.valueField
    } : {};
};

exports.getCellFromSpec = getCellFromSpec;

const revisedCell = (cell, dataset) => {
    const {color: color} = cell, colorField = (0, vutils_1.isArray)(color) ? color[0] : color;
    if (colorField) {
        (0, vutils_1.uniqArray)(dataset.map((d => d[colorField]))).length <= 1 && (cell.color = void 0);
    }
    if (cell.isTransposed) {
        const temp = cell.x;
        cell.x = cell.y, cell.y = temp;
    }
    return cell;
};

exports.revisedCell = revisedCell;

const removeInvalidFieldFromCell = (cell, fieldInfo) => {
    const fieldList = fieldInfo.map((f => f.fieldName)).concat([ chart_advisor_1.FOLD_NAME.toString(), chart_advisor_1.FOLD_VALUE.toString(), chart_advisor_1.FOLD_VALUE_MAIN.toString(), chart_advisor_1.FOLD_VALUE_SUB.toString(), chart_advisor_1.COLOR_FIELD.toString(), chart_advisor_1.GROUP_FIELD.toString() ]), cellNew = Object.assign({}, cell);
    return Object.keys(cellNew).forEach((key => {
        const fields = cellNew[key];
        if ((0, vutils_1.isArray)(fields)) {
            const filteredFields = fields.filter((field => fieldList.includes(field)));
            cellNew[key] = 0 === filteredFields.length ? void 0 : filteredFields;
        } else (0, vutils_1.isString)(fields) && (cellNew[key] = fieldList.includes(fields) ? fields : void 0);
    })), cellNew;
}, fillSpecTemplateWithData = (template, dataset, propsCell, totalTime) => {
    const {type: type} = template, fieldInfo = (0, field_1.getFieldInfoFromDataset)(dataset), tempCell = null != propsCell ? propsCell : (0, 
    exports.getCellFromSpec)(template);
    let cellNew = Object.assign({}, tempCell), datasetNew = dataset;
    const hasFold = (0, vutils_1.isArray)(cellNew.y) ? cellNew.y[0] === chart_advisor_1.FOLD_VALUE.toString() || cellNew.y[0] === chart_advisor_1.FOLD_VALUE_MAIN.toString() && cellNew.y[1] === chart_advisor_1.FOLD_VALUE_SUB.toString() : cellNew.y === chart_advisor_1.FOLD_VALUE.toString();
    cellNew = removeInvalidFieldFromCell(cellNew, fieldInfo);
    const context = {
        spec: template,
        dataset: datasetNew,
        cells: [ cellNew ],
        totalTime: totalTime
    };
    if ("bar" === type && template.player) {
        const {spec: spec} = (0, transformers_1.sequenceData)(context);
        return spec;
    }
    if ([ "bar", "line" ].includes(type)) {
        if (hasFold) {
            const {foldInfo: foldInfo} = cellNew, {foldMap: foldMap} = foldInfo;
            datasetNew = (0, dataTable_1.foldDataTableByYField)(datasetNew, Object.keys(foldMap), fieldInfo);
        }
        if (cellNew.color === chart_advisor_1.COLOR_FIELD.toString()) {
            const {cartesianInfo: cartesianInfo} = cellNew, colorFields = cartesianInfo.fieldList;
            datasetNew = datasetNew.map((data => {
                const colorItem = colorFields.map((field => data[field])).join("-");
                return Object.assign(Object.assign({}, data), {
                    [chart_advisor_1.COLOR_FIELD]: colorItem
                });
            }));
        }
        const contextNew = {
            spec: template,
            dataset: datasetNew,
            cells: [ cellNew ],
            totalTime: totalTime
        }, {spec: spec1} = (0, transformers_1.data)(contextNew), {spec: spec} = (0, transformers_1.legend)(Object.assign(Object.assign({}, contextNew), {
            spec: spec1
        }));
        return spec;
    }
    if ([ "pie", "scatter", "rose", "radar", "waterfall", "boxPlot" ].includes(type)) {
        if (hasFold) {
            const {foldInfo: foldInfo} = cellNew, {foldMap: foldMap} = foldInfo;
            datasetNew = (0, dataTable_1.foldDatasetByYField)(datasetNew, Object.keys(foldMap), fieldInfo);
        }
        if (cellNew.color === chart_advisor_1.COLOR_FIELD.toString()) {
            const {cartesianInfo: cartesianInfo} = cellNew, colorFields = cartesianInfo.fieldList;
            datasetNew = datasetNew.map((data => {
                const colorItem = colorFields.map((field => data[field])).join("-");
                return Object.assign(Object.assign({}, data), {
                    [chart_advisor_1.COLOR_FIELD]: colorItem
                });
            }));
        }
        const contextNew = {
            spec: template,
            dataset: datasetNew,
            cells: [ cellNew ],
            totalTime: totalTime
        }, {spec: spec} = (0, transformers_1.data)(contextNew);
        return spec;
    }
    if ("common" === type) {
        let mainSeriesData = datasetNew, subSeriesData = datasetNew;
        if (hasFold) {
            const {foldInfo: foldInfo} = cellNew, {foldMap: foldMap} = foldInfo;
            mainSeriesData = (0, dataTable_1.foldDatasetByYField)(datasetNew, [ Object.keys(foldMap)[0] ], fieldInfo, chart_advisor_1.FOLD_NAME, chart_advisor_1.FOLD_VALUE_MAIN), 
            subSeriesData = (0, dataTable_1.foldDatasetByYField)(datasetNew, [ Object.keys(foldMap)[1] ], fieldInfo, chart_advisor_1.FOLD_NAME, chart_advisor_1.FOLD_VALUE_SUB);
        }
        const {spec: spec1} = (0, transformers_1.data)(context), {spec: finalSpec} = (0, 
        transformers_1.legend)(Object.assign(Object.assign({}, context), {
            spec: spec1
        })), {cartesianInfo: cartesianInfo, y: y} = cellNew;
        if (finalSpec.series && finalSpec.series[0]) {
            finalSpec.series[0].seriesField = chart_advisor_1.COLOR_FIELD;
            const colorFields = cartesianInfo ? cartesianInfo.fieldList : void 0;
            finalSpec.series[0].data = {
                id: finalSpec.data.id + "_bar",
                values: mainSeriesData.map((d => {
                    const colorItem = (0, vutils_1.isArray)(colorFields) ? colorFields.map((field => d[field])).join("-") : y[0];
                    return Object.assign(Object.assign({}, d), {
                        [chart_advisor_1.COLOR_FIELD]: colorItem
                    });
                }))
            };
        }
        if (finalSpec.series && finalSpec.series[1]) {
            finalSpec.series[1].seriesField = chart_advisor_1.COLOR_FIELD;
            const colorFields = cartesianInfo ? cartesianInfo.fieldList : void 0;
            finalSpec.series[1].data = {
                id: finalSpec.data.id + "_line",
                values: subSeriesData.map((d => {
                    const colorItem = (0, vutils_1.isArray)(colorFields) ? colorFields.map((field => d[field])).join("-") : y[1];
                    return Object.assign(Object.assign({}, d), {
                        [chart_advisor_1.COLOR_FIELD]: colorItem
                    });
                }))
            };
        }
        return finalSpec;
    }
    if ("wordCloud" === type) {
        const {spec: spec} = (0, transformers_1.wordCloudData)(context);
        return spec;
    }
    if ("funnel" === type) {
        const {spec: spec} = (0, transformers_1.funnelData)(context);
        return spec;
    }
    if ("sankey" === type) {
        const {spec: spec} = (0, transformers_1.sankeyData)(context);
        return spec;
    }
    const {spec: spec} = (0, transformers_1.data)(context);
    return spec;
};

exports.fillSpecTemplateWithData = fillSpecTemplateWithData;
//# sourceMappingURL=spec.js.map