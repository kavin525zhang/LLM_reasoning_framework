"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DataInsightAtom = void 0;

const atom_1 = require("../../types/atom"), base_1 = require("../base"), vutils_1 = require("@visactor/vutils"), dataProcess_1 = require("./dataProcess"), type_1 = require("./type"), algorithms_1 = require("./algorithms"), prompt_1 = require("./prompt"), template_1 = require("./algorithms/template");

class DataInsightAtom extends base_1.BaseAtom {
    constructor(context, option) {
        super(context, option), this.name = atom_1.AtomName.DATA_INSIGHT, this.isLLMAtom = !0;
    }
    buildDefaultContext(context) {
        return (0, vutils_1.merge)({}, {
            spec: {},
            insights: []
        }, context);
    }
    buildDefaultOptions() {
        return Object.assign(Object.assign({}, super.buildDefaultOptions()), {
            algorithms: [ type_1.AlgorithmType.OverallTrending, type_1.AlgorithmType.AbnormalTrend, type_1.AlgorithmType.PearsonCorrelation, type_1.AlgorithmType.SpearmanCorrelation, type_1.AlgorithmType.StatisticsAbnormal, type_1.AlgorithmType.LOFOutlier, type_1.AlgorithmType.DbscanOutlier, type_1.AlgorithmType.MajorityValue, type_1.AlgorithmType.PageHinkley, type_1.AlgorithmType.TurningPoint, type_1.AlgorithmType.StatisticsBase, type_1.AlgorithmType.Volatility ],
            isLimitedbyChartType: !0,
            language: "chinese",
            usePolish: !0
        });
    }
    shouldRunByContextUpdate(context) {
        return !0;
    }
    getLLMMessages(query) {
        var _a;
        const {insights: insights} = this.context, language = null === (_a = this.options) || void 0 === _a ? void 0 : _a.language, addtionContent = this.getHistoryLLMMessages(query);
        return [ {
            role: "system",
            content: (0, prompt_1.getPolishPrompt)(language)
        }, {
            role: "user",
            content: JSON.stringify({
                insights: insights.map((insight => {
                    var _a, _b;
                    return {
                        type: insight.type,
                        content: null === (_a = insight.textContent) || void 0 === _a ? void 0 : _a.content,
                        variables: (null === (_b = insight.textContent) || void 0 === _b ? void 0 : _b.variables) ? Object.keys(insight.textContent.variables).reduce(((acc, key) => {
                            var _a;
                            return Object.assign(Object.assign({}, acc), {
                                [key]: Object.assign(Object.assign({}, null === (_a = insight.textContent) || void 0 === _a ? void 0 : _a.variables[key]), {
                                    value: null,
                                    formatValue: null
                                })
                            });
                        }), {}) : {}
                    };
                }))
            })
        }, ...addtionContent ];
    }
    parseLLMContent(resJson) {
        const {results: results} = resJson;
        if (!results) return console.error("Insights polish error in LLM"), Object.assign(Object.assign({}, this.context), {
            error: "Insights polish error in LLM"
        });
        const newInsights = this.context.insights.map(((insight, index) => {
            var _a, _b;
            return Object.assign(Object.assign({}, insight), {
                textContent: (0, template_1.addPlainText)({
                    content: results[index] || (null === (_a = insight.textContent) || void 0 === _a ? void 0 : _a.content),
                    variables: null === (_b = insight.textContent) || void 0 === _b ? void 0 : _b.variables
                })
            });
        }));
        return Object.assign(Object.assign({}, this.context), {
            insights: newInsights
        });
    }
    runBeforeLLM() {
        var _a;
        this.isLLMAtom = !1 !== (null === (_a = this.options) || void 0 === _a ? void 0 : _a.usePolish);
        const dataInfo = (0, dataProcess_1.extractDataFromContext)(this.context), insights = (0, 
        algorithms_1.getInsights)(Object.assign(Object.assign({}, dataInfo), {
            spec: this.context.spec
        }), this.options), newContext = Object.assign(Object.assign({}, this.context), {
            chartType: dataInfo.chartType,
            fieldInfo: dataInfo.fieldInfo,
            insights: insights
        });
        return this.updateContext(newContext), 0 === insights.length && (this.isLLMAtom = !1), 
        this.context;
    }
}

exports.DataInsightAtom = DataInsightAtom;
//# sourceMappingURL=index.js.map