"use strict";

var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Schedule = void 0;

const vutils_1 = require("@visactor/vutils"), atom_1 = require("../types/atom"), base_1 = require("../atom/base"), atom_2 = require("../atom"), dataClean_1 = require("../atom/dataClean/dataClean");

class Schedule {
    constructor(atomList, options, context) {
        this.atomList = atomList, this.options = options || {}, this.query = "", this.atomInstaces = atomList.map((atomName => this.atomFactory(atomName))), 
        this.setNewTask(context);
    }
    initContext() {
        this.context = {}, this.atomInstaces.forEach((atom => {
            this.context = atom.buildDefaultContext(this.context), atom.reset();
        }));
    }
    getAtomOptions(atomName) {
        return (0, vutils_1.merge)({}, this.options[atom_1.AtomName.BASE], this.options[atomName]);
    }
    atomFactory(atomName) {
        const options = this.getAtomOptions(atomName);
        switch (atomName) {
          case atom_1.AtomName.DATA_EXTRACT:
            return new atom_2.DataExtractionAtom(this.context, options);

          case atom_1.AtomName.DATA_CLEAN:
            return new dataClean_1.DataCleanAtom(this.context, options);

          case atom_1.AtomName.MULTIPLE_DATA_CLEAN:
            return new atom_2.MultipleDataCleanAtom(this.context, options);

          case atom_1.AtomName.DATA_QUERY:
            return new atom_2.DataQueryAtom(this.context, options);

          case atom_1.AtomName.DATA_INSIGHT:
            return new atom_2.DataInsightAtom(this.context, options);

          case atom_1.AtomName.SPEC_INSIGHT:
            return new atom_2.SpecInsightAtom(this.context, options);

          case atom_1.AtomName.CHART_COMMAND:
            return new atom_2.ChartCommandAtom(this.context, options);

          case atom_1.AtomName.MULTIPLE_CHART_COMMAND:
            return new atom_2.MultipleChartCommandAtom(this.context, options);

          case atom_1.AtomName.CHART_GENERATE:
            return new atom_2.ChartGeneratorAtom(this.context, options);

          case atom_1.AtomName.CHART_QA_EXTRACTION:
            return new atom_2.ChartQAExtraction(this.context, options);

          case atom_1.AtomName.CUSTOM_PROMPT:
            return new atom_2.CustomPrompt(this.context, options);

          case atom_1.AtomName.VCHART_SPEC:
            return new atom_2.VChartSpec(this.context, options);

          default:
            return new base_1.BaseAtom(this.context, options);
        }
    }
    parseSubTasks(query) {
        let taskMapping = {};
        return this.atomList.forEach((name => {
            taskMapping = Object.assign(Object.assign({}, taskMapping), {
                [name]: {
                    shouldRun: !0,
                    query: query
                }
            });
        })), taskMapping;
    }
    addUsage(oldUsage, newUsage) {
        const result = {};
        if (!newUsage) return oldUsage;
        for (const key in oldUsage) if (Object.prototype.hasOwnProperty.call(oldUsage, key)) {
            const curKey = key;
            result[curKey] = (oldUsage[curKey] || 0) + ((null == newUsage ? void 0 : newUsage[curKey]) || 0);
        }
        return result;
    }
    run(query, shouldRunList) {
        var _a;
        return __awaiter(this, void 0, void 0, (function*() {
            this.query = query || "";
            const subTasks = this.parseSubTasks(query);
            let usage = {
                prompt_tokens: 0,
                completion_tokens: 0,
                total_tokens: 0
            };
            for (const atom of this.atomInstaces) {
                const {shouldRun: shouldRun, query: taskQuery} = (null == subTasks ? void 0 : subTasks[atom.name]) || {};
                !1 !== (null == shouldRunList ? void 0 : shouldRunList[atom.name]) && (shouldRun || atom.shouldRunByContextUpdate(this.context)) && (this.context = yield atom.run({
                    context: this.context,
                    query: taskQuery
                }), usage = this.addUsage(usage, null === (_a = atom.getContext()) || void 0 === _a ? void 0 : _a.usage));
            }
            return this.context = Object.assign(Object.assign({}, this.context), {
                usage: usage
            }), this.context;
        }));
    }
    setNewTask(context) {
        this.initContext(), this.updateContext(context), this.atomInstaces.forEach((atom => {
            atom.reset(this.context), atom.clearHistory();
        }));
    }
    updateOptions(options) {
        this.options = (0, vutils_1.merge)({}, this.options, options), this.atomInstaces.forEach((atom => atom.updateOptions(this.getAtomOptions(atom.name))));
    }
    updateContext(context, isReplace = !1) {
        this.context = isReplace ? context : (0, vutils_1.merge)({}, this.context, context);
    }
    getContext(atomName) {
        if (atomName) {
            const atomInstaces = this.atomInstaces.find((atom => atom.name === atomName));
            return atomInstaces ? atomInstaces.getContext() : (console.error(`Doesn't exist ${atomName}`), 
            null);
        }
        return this.context;
    }
}

exports.Schedule = Schedule;
//# sourceMappingURL=index.js.map