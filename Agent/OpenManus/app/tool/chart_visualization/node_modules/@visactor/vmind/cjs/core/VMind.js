"use strict";

var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
}, __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

const llm_1 = require("./llm"), types_1 = require("../types"), applications_1 = require("../applications"), field_1 = require("../utils/field"), dataTable_1 = require("../utils/dataTable"), spec_1 = require("../utils/spec"), video_1 = require("../utils/video"), vutils_1 = require("@visactor/vutils");

class VMind {
    constructor(options) {
        this._FPS = 30, this.options = (0, vutils_1.merge)({
            showThoughts: !0
        }, options), this.llm = new llm_1.LLMManage((0, applications_1.getScheduleLLmOptions)(options)), 
        this.data2ChartSchedule = (0, applications_1.getData2ChartSchedule)(this.llm, options), 
        this.dataQuerySchedule = (0, applications_1.getDataQuerySchedule)(this.llm, options), 
        this.text2DataTableSchedule = (0, applications_1.getText2DataSchedule)(this.llm, options), 
        this.text2ChartSchedule = (0, applications_1.getText2ChartSchedule)(this.llm, options), 
        this.dataInsightSchedule = (0, applications_1.getDataInsightSchedule)(this.llm, options);
    }
    updateOptions(options) {
        this.options = (0, vutils_1.merge)({
            showThoughts: !0
        }, options), this.llm.updateOptions((0, applications_1.getScheduleLLmOptions)(this.options));
    }
    parseCSVData(csvString) {
        return (0, dataTable_1.parseCSVData)(csvString);
    }
    getFieldInfo(dataset) {
        return (0, field_1.getFieldInfoFromDataset)(dataset);
    }
    dataQuery(userPrompt, dataset, fieldInfo) {
        return __awaiter(this, void 0, void 0, (function*() {
            this.dataQuerySchedule.setNewTask({
                command: userPrompt,
                fieldInfo: fieldInfo,
                dataTable: dataset
            }), this.dataQuerySchedule.updateOptions({
                base: {
                    showThoughts: this.options.showThoughts
                }
            });
            const {dataTable: dataTable, fieldInfo: newFieldInfo, usage: usage, error: error} = yield this.dataQuerySchedule.run();
            return {
                dataTable: dataTable,
                fieldInfo: newFieldInfo,
                usage: usage,
                error: error
            };
        }));
    }
    text2Data(text, userPrompt, options) {
        return __awaiter(this, void 0, void 0, (function*() {
            const {fieldInfo: fieldInfo, hierarchicalClustering: hierarchicalClustering, clusterThreshold: clusterThreshold} = options || {};
            this.text2DataTableSchedule.setNewTask({
                text: text,
                fieldInfo: (null == fieldInfo ? void 0 : fieldInfo.length) ? fieldInfo : []
            }), this.text2DataTableSchedule.updateOptions({
                base: {
                    showThoughts: this.options.showThoughts
                },
                dataClean: {
                    hierarchicalClustering: hierarchicalClustering,
                    clusterThreshold: clusterThreshold
                }
            });
            const {dataTable: dataTable, fieldInfo: newFieldInfo, usage: usage, clusterResult: clusterResult, error: error} = yield this.text2DataTableSchedule.run(userPrompt), {fieldInfo: extractFieldInfo, dataTable: extractDataTable} = this.text2DataTableSchedule.getContext(types_1.AtomName.DATA_EXTRACT);
            return {
                extractDataTable: extractDataTable,
                extractFieldInfo: extractFieldInfo,
                dataTable: dataTable,
                fieldInfo: newFieldInfo,
                usage: usage,
                clusterResult: clusterResult,
                error: error
            };
        }));
    }
    text2Chart(text, userPrompt, options) {
        return __awaiter(this, void 0, void 0, (function*() {
            const _a = options || {}, {fieldInfo: fieldInfo, enableDataQuery: enableDataQuery = !1} = _a, chartOptions = __rest(_a, [ "fieldInfo", "enableDataQuery" ]);
            this.text2ChartSchedule.setNewTask({
                text: text,
                fieldInfo: (null == fieldInfo ? void 0 : fieldInfo.length) ? fieldInfo : [],
                command: userPrompt
            });
            const shouldRunList = {
                [types_1.AtomName.CHART_COMMAND]: !userPrompt,
                [types_1.AtomName.DATA_QUERY]: enableDataQuery
            };
            this.text2ChartSchedule.updateOptions({
                base: {
                    showThoughts: this.options.showThoughts
                },
                chartGenerate: Object.assign({}, chartOptions)
            });
            const {chartAdvistorRes: chartAdvistorRes, spec: spec, command: command, cell: cell, vizSchema: vizSchema, dataTable: dataTable, time: time, fieldInfo: newFieldInfo, usage: usage, error: error} = yield this.text2ChartSchedule.run(userPrompt, shouldRunList);
            return {
                spec: spec,
                command: command,
                chartAdvistorRes: chartAdvistorRes,
                cell: cell,
                vizSchema: vizSchema,
                time: time,
                dataTable: dataTable,
                fieldInfo: newFieldInfo,
                usage: usage,
                error: error
            };
        }));
    }
    generateChart(userPrompt, fieldInfo, dataset, options) {
        return __awaiter(this, void 0, void 0, (function*() {
            const {enableDataQuery: enableDataQuery = !1} = options || {};
            this.data2ChartSchedule.updateOptions({
                base: {
                    showThoughts: this.options.showThoughts
                },
                chartGenerate: Object.assign({}, options)
            }), this.data2ChartSchedule.setNewTask({
                fieldInfo: fieldInfo,
                dataTable: dataset,
                command: userPrompt || ""
            });
            const shouldRunList = {
                [types_1.AtomName.DATA_QUERY]: enableDataQuery,
                [types_1.AtomName.CHART_COMMAND]: !userPrompt
            }, {chartType: chartType, chartAdvistorRes: chartAdvistorRes, spec: spec, command: command, cell: cell, vizSchema: vizSchema, dataTable: dataTable, time: time, usage: usage, error: error} = yield this.data2ChartSchedule.run(void 0, shouldRunList);
            return {
                chartType: chartType,
                spec: spec,
                command: command,
                chartAdvistorRes: chartAdvistorRes,
                cell: cell,
                vizSchema: vizSchema,
                dataTable: dataTable,
                time: time,
                usage: usage,
                error: error
            };
        }));
    }
    getInsights(spec, options) {
        return __awaiter(this, void 0, void 0, (function*() {
            this.dataInsightSchedule.setNewTask({
                spec: spec
            }), this.dataInsightSchedule.updateOptions({
                base: {
                    showThoughts: this.options.showThoughts
                },
                dataInsight: options || {}
            });
            const shouldRunList = {
                [types_1.AtomName.DATA_INSIGHT]: !0,
                [types_1.AtomName.SPEC_INSIGHT]: !!(null == options ? void 0 : options.enableInsightAnnotation)
            }, {insights: insights, usage: usage, error: error, newSpec: newSpec} = yield this.dataInsightSchedule.run(void 0, shouldRunList);
            return {
                insights: insights,
                usage: usage,
                error: error,
                newSpec: newSpec
            };
        }));
    }
    updateSpecByInsights(spec, insights, options) {
        return __awaiter(this, void 0, void 0, (function*() {
            const {chartType: chartType} = options || {}, shouldRunList = {
                [types_1.AtomName.DATA_INSIGHT]: !1,
                [types_1.AtomName.SPEC_INSIGHT]: !0
            };
            this.dataInsightSchedule.setNewTask({
                spec: spec,
                insights: insights,
                chartType: chartType
            });
            const {error: error, newSpec: newSpec} = yield this.dataInsightSchedule.run(void 0, shouldRunList);
            return {
                error: error,
                newSpec: newSpec
            };
        }));
    }
    fillSpecWithData(spec, dataset, cell) {
        return (0, spec_1.fillSpecTemplateWithData)(spec, dataset, cell);
    }
    exportVideo(spec, time, outerPackages, mode) {
        return __awaiter(this, void 0, void 0, (function*() {
            const {VChart: VChart, FFmpeg: FFmpeg, fetchFile: fetchFile, ManualTicker: ManualTicker} = outerPackages;
            yield (0, video_1._chatToVideoWasm)(this._FPS, spec, time, "out", outerPackages, mode);
            return FFmpeg.FS("readFile", "out.mp4").buffer;
        }));
    }
    exportGIF(spec, time, outerPackages, mode) {
        return __awaiter(this, void 0, void 0, (function*() {
            const {VChart: VChart, FFmpeg: FFmpeg, fetchFile: fetchFile} = outerPackages;
            yield (0, video_1._chatToVideoWasm)(this._FPS, spec, time, "out", outerPackages, mode), 
            yield FFmpeg.run("-i", "out.mp4", "-filter_complex", "[0:v] palettegen", "palette.png"), 
            yield FFmpeg.run("-i", "out.mp4", "-i", "palette.png", "-filter_complex", "[0:v][1:v] paletteuse", "out.gif");
            return FFmpeg.FS("readFile", "out.gif").buffer;
        }));
    }
}

exports.default = VMind;
//# sourceMappingURL=VMind.js.map