"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assignDualAxis = exports.assignFunnelChart = exports.assignMeasureCard = exports.assignPieChart = exports.sortTimeDim = exports.assignScatterPlot = exports.processCombination = exports.assignPivotCharts = void 0;
const vutils_1 = require("@visactor/vutils");
const dataUtils = __importStar(require("./dataUtil"));
const fieldUtils_1 = require("./fieldUtils");
const constant_1 = require("./constant");
const assignPivotCharts = (originDataset, dimList, measureList, aliasMapOld, MAX_PIVOT_ROW, MAX_PIVOT_COLUMN) => {
    const aliasMap = (0, vutils_1.cloneDeep)(aliasMapOld);
    let dataset = (0, vutils_1.cloneDeep)(originDataset);
    const cell = {
        x: [],
        y: [],
        row: [],
        column: [],
        color: [],
        size: [],
        angle: []
    };
    if (dimList.length === 0 || measureList.length === 0) {
        return { cell, dataset };
    }
    let nowDimIndex = 0;
    while ((cell.row.length < MAX_PIVOT_ROW || cell.column.length < MAX_PIVOT_COLUMN) &&
        nowDimIndex + 1 < dimList.length) {
        if (cell.row.length <= cell.column.length) {
            cell.row.push(dimList[nowDimIndex]);
        }
        else {
            cell.column.push(dimList[nowDimIndex]);
        }
        nowDimIndex++;
    }
    cell.x.push(dimList[nowDimIndex]);
    nowDimIndex++;
    const colorFields = [];
    colorFields.push(...dimList.slice(nowDimIndex));
    const measuresListLength = measureList.length;
    let colorFieldsIncludeMeasure = false;
    if (measuresListLength > 1) {
        aliasMap[constant_1.FOLD_NAME] = `指标名称`;
        aliasMap[constant_1.FOLD_VALUE] = `指标值`;
        colorFields.push(constant_1.FOLD_NAME);
        colorFieldsIncludeMeasure = true;
        cell.y.push(constant_1.FOLD_VALUE);
    }
    else if (measuresListLength === 1) {
        cell.y.push(measureList[0]);
    }
    const colorFieldsValues = colorFields.map((uniqueId) => (0, fieldUtils_1.getDomainFromDataset)(dataset, uniqueId));
    const dimItemsLen = (0, fieldUtils_1.getDomainFromDataset)(dataset, cell.x[0]).length;
    const colorItemsLen = (0, fieldUtils_1.productLength)(colorFieldsValues);
    if (dimItemsLen > constant_1.X_MAX_COUNT ||
        dataset.length > constant_1.MAX_POINT_COUNT ||
        (colorItemsLen > constant_1.LEGEND_MAX_COUNT && dataset.length > constant_1.LEGEND_MAX_POINT_COUNT)) {
        return {
            error: true,
            errMsg: `数据量或图例项过多，请使用表格展示。`
        };
    }
    const colorItemsList = (0, fieldUtils_1.legendProduct)(colorFieldsValues, colorFieldsIncludeMeasure);
    let colorItems = colorItemsList.map(d => d.join('-'));
    if (colorFields.length > 0) {
        dataset = dataset.map((data) => {
            const colorItem = colorFields.map(field => data[field]).join('-');
            return {
                ...data,
                [constant_1.COLOR_FIELD]: colorItem
            };
        });
        const _colorItems = (0, fieldUtils_1.getDomainFromDataset)(dataset, constant_1.COLOR_FIELD);
        colorItems = colorItems.filter((d) => _colorItems.includes(d));
        aliasMap[constant_1.COLOR_FIELD] = `图例项`;
        cell.color.push(constant_1.COLOR_FIELD);
        cell.cartesianInfo = (0, fieldUtils_1.getCartesianInfo)(colorFields, constant_1.COLOR_FIELD);
        if (measuresListLength > 1) {
            cell.foldInfo = (0, fieldUtils_1.getFoldInfo)(measureList, constant_1.FOLD_NAME, constant_1.FOLD_VALUE, aliasMap);
        }
    }
    return { cell, dataset, colorItems, aliasMap };
};
exports.assignPivotCharts = assignPivotCharts;
const processCombination = (originDataset, dimList, measureList, aliasMapOld, MAX_PIVOT_ROW, MAX_PIVOT_COLUMN) => {
    const aliasMap = (0, vutils_1.cloneDeep)(aliasMapOld);
    const dataset = (0, vutils_1.cloneDeep)(originDataset);
    const metaDatas = [];
    measureList.forEach(measure => {
        const _allPillsIdList = [].concat(dimList, [measure]);
        const _dataset = (0, fieldUtils_1.retainDatasetField)(dataset, _allPillsIdList);
        const metaData = (0, exports.assignPivotCharts)(_dataset, dimList, [measure], aliasMap, MAX_PIVOT_ROW, MAX_PIVOT_COLUMN);
        metaDatas.push(metaData);
    });
    return metaDatas;
};
exports.processCombination = processCombination;
const assignScatterPlot = (originDataset, dimList, measureList, aliasMapOld) => {
    const aliasMap = (0, vutils_1.cloneDeep)(aliasMapOld);
    let dataset = (0, vutils_1.cloneDeep)(originDataset);
    const scatterCell = {
        x: [],
        y: [],
        row: [],
        column: [],
        color: [],
        size: [],
        angle: [],
        group: [constant_1.GROUP_FIELD]
    };
    let remainMeasure = measureList.length;
    if (dimList.length === 0 || measureList.length < 2) {
        return { scatterCell, dataset };
    }
    scatterCell.x.push(measureList[0]);
    scatterCell.y.push(measureList[1]);
    remainMeasure -= 2;
    if (measureList.length > 2) {
        scatterCell.size.push(measureList[2]);
    }
    remainMeasure -= 1;
    const groupDimensions = [];
    if (dimList.length > 1) {
        scatterCell.color.push(dimList[1]);
        groupDimensions.concat(dimList.slice(2));
    }
    else {
        groupDimensions.concat(dimList.slice(1));
        if (measureList.length > 3) {
            scatterCell.color.push(measureList[3]);
            remainMeasure -= 1;
        }
    }
    if (remainMeasure > 0) {
        const voidCell = {
            x: [],
            y: [],
            row: [],
            column: [],
            color: [],
            size: [],
            angle: []
        };
        return { scatterCell: voidCell, dataset };
    }
    const colorFieldsValues = scatterCell.color.map((uniqueId) => (0, fieldUtils_1.getDomainFromDataset)(dataset, uniqueId));
    const colorItemsLen = (0, fieldUtils_1.productLength)(colorFieldsValues);
    if (dataset.length > constant_1.MAX_POINT_COUNT ||
        (colorItemsLen > constant_1.LEGEND_MAX_COUNT && dataset.length > constant_1.LEGEND_MAX_POINT_COUNT)) {
        return {
            error: true,
            errMsg: `数据量或图例项过多，请使用表格展示。`
        };
    }
    const colorItemsList = (0, fieldUtils_1.legendProduct)(colorFieldsValues, false);
    const colorItems = colorItemsList.map(d => d.join('-'));
    dataset = dataset.map((data) => {
        const groupItem = groupDimensions.map((field) => data[field]).join('-');
        return {
            ...data,
            [constant_1.GROUP_FIELD]: groupItem
        };
    });
    aliasMap[constant_1.GROUP_FIELD] = `细分`;
    return {
        scatterCell,
        dataset: [[[dataset]]],
        colorItems,
        aliasMap
    };
};
exports.assignScatterPlot = assignScatterPlot;
const sortTimeDim = (dimList, MAX_PIVOT_ROW, MAX_PIVOT_COLUMN) => {
    const dimListLength = dimList.length;
    const firstTimeIndex = dimList.findIndex(dim => {
        const isDateType = dataUtils.isTemporal(dim.dataType);
        return isDateType;
    });
    let targetPosition;
    if (MAX_PIVOT_COLUMN + MAX_PIVOT_ROW > dimListLength - 1) {
        targetPosition = dimListLength - 1;
    }
    else {
        targetPosition = MAX_PIVOT_ROW + MAX_PIVOT_COLUMN;
    }
    const idList = dimList.map(dim => dim.uniqueID);
    const timeItem = idList[firstTimeIndex];
    idList.splice(firstTimeIndex, 1);
    idList.splice(targetPosition, 0, timeItem);
    return idList;
};
exports.sortTimeDim = sortTimeDim;
const assignPieChart = (originDataset, dimList, measureList, aliasMapOld) => {
    const aliasMap = (0, vutils_1.cloneDeep)(aliasMapOld);
    let dataset = (0, vutils_1.cloneDeep)(originDataset);
    const pieCell = {
        x: [],
        y: [],
        row: [],
        column: [],
        color: [],
        size: [],
        angle: []
    };
    if (!(dimList.length === 0 && measureList.length >= 3)) {
        return { pieCell, dataset };
    }
    const colorFields = [...dimList];
    let colorFieldsIncludeMeasure = false;
    const measuresListLength = measureList.length;
    if (measuresListLength > 1) {
        aliasMap[constant_1.FOLD_NAME] = `指标名称`;
        aliasMap[constant_1.FOLD_VALUE] = `指标值`;
        colorFields.push(constant_1.FOLD_NAME);
        colorFieldsIncludeMeasure = true;
        pieCell.angle.push(constant_1.FOLD_VALUE);
    }
    else if (measuresListLength === 1) {
        pieCell.angle.push(measureList[0]);
    }
    const colorFieldsValues = colorFields.map((uniqueId) => (0, fieldUtils_1.getDomainFromDataset)(dataset, uniqueId));
    const colorItemsLen = (0, fieldUtils_1.productLength)(colorFieldsValues);
    if (dataset.length > constant_1.MAX_POINT_COUNT ||
        (colorItemsLen > constant_1.LEGEND_MAX_COUNT && dataset.length > constant_1.LEGEND_MAX_POINT_COUNT)) {
        return {
            error: true,
            errMsg: `数据量或图例项过多，请使用表格展示。`
        };
    }
    const colorItemsList = (0, fieldUtils_1.legendProduct)(colorFieldsValues, colorFieldsIncludeMeasure);
    let colorItems = colorItemsList.map(d => d.join('-'));
    if (colorFields.length > 0) {
        dataset = dataset.map((data) => {
            const colorItem = colorFields.map(field => data[field]).join('-');
            return {
                ...data,
                [constant_1.COLOR_FIELD]: colorItem
            };
        });
        const _colorItems = (0, fieldUtils_1.getDomainFromDataset)(dataset, constant_1.COLOR_FIELD);
        colorItems = colorItems.filter((d) => _colorItems.includes(d));
        aliasMap[constant_1.COLOR_FIELD] = `图例项`;
        pieCell.color.push(constant_1.COLOR_FIELD);
        pieCell.cartesianInfo = (0, fieldUtils_1.getCartesianInfo)(colorFields, constant_1.COLOR_FIELD);
        if (measuresListLength > 1) {
            pieCell.foldInfo = (0, fieldUtils_1.getFoldInfo)(measureList, constant_1.FOLD_NAME, constant_1.FOLD_VALUE, aliasMap);
        }
    }
    return { pieCell, dataset, colorItems, aliasMap };
};
exports.assignPieChart = assignPieChart;
const assignMeasureCard = (originDataset, dimList, measureList, aliasMapOld) => {
    const aliasMap = (0, vutils_1.cloneDeep)(aliasMapOld);
    const dataset = (0, vutils_1.cloneDeep)(originDataset);
    const cardDataset = (0, fieldUtils_1.fold)(dataset, measureList, constant_1.FOLD_NAME, constant_1.FOLD_VALUE, aliasMap);
    const cardCell = {
        x: [],
        y: [],
        row: [],
        column: [],
        color: [constant_1.FOLD_NAME],
        size: [constant_1.FOLD_VALUE],
        angle: [],
        value: [constant_1.FOLD_VALUE],
        text: [constant_1.FOLD_NAME]
    };
    return { cardCell, dataset: cardDataset };
};
exports.assignMeasureCard = assignMeasureCard;
const assignFunnelChart = (originDataset, dimList, measureList, aliasMapOld) => {
    const aliasMap = (0, vutils_1.cloneDeep)(aliasMapOld);
    const dataset = (0, vutils_1.cloneDeep)(originDataset);
    const funnelCell = {
        x: [],
        y: [],
        row: [],
        column: [],
        color: [],
        size: [],
        angle: []
    };
    if (!((dimList.length === 1 && measureList.length === 1) || (dimList.length === 0 && measureList.length >= 2))) {
        return { funnelCell, dataset };
    }
    const measuresListLength = measureList.length;
    if (measuresListLength > 1) {
        aliasMap[constant_1.FOLD_NAME] = `指标名称`;
        aliasMap[constant_1.FOLD_VALUE] = `指标值`;
        funnelCell.size.push(constant_1.FOLD_VALUE);
        funnelCell.foldInfo = (0, fieldUtils_1.getFoldInfo)(measureList, constant_1.FOLD_NAME, constant_1.FOLD_VALUE, aliasMap);
    }
    else if (measuresListLength === 1) {
        funnelCell.size.push(measureList[0]);
    }
    const dimensionIdListLength = dimList.length;
    if (dimensionIdListLength > 0) {
        funnelCell.color.push(dimList[0]);
    }
    else if (dimensionIdListLength === 0 && measuresListLength > 1) {
        funnelCell.size.push(constant_1.FOLD_NAME);
    }
    return { funnelCell, dataset };
};
exports.assignFunnelChart = assignFunnelChart;
const assignDualAxis = (originDataset, dimList, measureList, subMeasureList, aliasMapOld) => {
    const aliasMap = (0, vutils_1.cloneDeep)(aliasMapOld);
    let dataset = (0, vutils_1.cloneDeep)(originDataset);
    const cell = {
        x: [],
        y: [],
        row: [],
        column: [],
        color: [],
        cartesianInfo: null,
        foldInfo: null
    };
    const singleSide = isMain => {
        let _measuresIdList;
        let removeIdList;
        let FOLD_VALUE_FIELD;
        let aliasFoldValue;
        if (isMain) {
            _measuresIdList = measureList;
            removeIdList = subMeasureList;
            FOLD_VALUE_FIELD = constant_1.FOLD_VALUE_MAIN;
            aliasFoldValue = `指标值(主轴)`;
        }
        else {
            _measuresIdList = subMeasureList;
            removeIdList = measureList;
            FOLD_VALUE_FIELD = constant_1.FOLD_VALUE_SUB;
            aliasFoldValue = `指标值(次轴)`;
        }
        if (_measuresIdList.length === 0) {
            return [];
        }
        let sideDataset = (0, fieldUtils_1.removeDatasetField)(dataset, removeIdList);
        sideDataset = (0, fieldUtils_1.fold)(sideDataset, _measuresIdList, constant_1.FOLD_NAME, FOLD_VALUE_FIELD, aliasMap, false);
        aliasMap[FOLD_VALUE_FIELD] = aliasFoldValue;
        cell.y.push(FOLD_VALUE_FIELD);
        return sideDataset;
    };
    const datasetMain = singleSide(true);
    const datasetSub = singleSide(false);
    dataset = [].concat(datasetMain, datasetSub);
    const dimensionIdList = dimList;
    const measureIdList = measureList.concat(subMeasureList);
    const colorFields = [];
    if (dimensionIdList.length > 0) {
        cell.x.push(String(dimensionIdList[0]));
        colorFields.push(...dimensionIdList.slice(1));
    }
    const measuresListLength = measureIdList.length;
    if (measuresListLength > 0) {
        aliasMap[constant_1.FOLD_NAME] = `指标名称`;
        colorFields.push(constant_1.FOLD_NAME);
    }
    const colorFieldsValues = colorFields.map((uniqueId) => (0, fieldUtils_1.getDomainFromDataset)(dataset, uniqueId));
    const dimItemsLen = (0, fieldUtils_1.getDomainFromDataset)(dataset, cell.x[0]).length;
    const colorItemsLen = (0, fieldUtils_1.productLength)(colorFieldsValues);
    if (dimItemsLen > constant_1.X_MAX_COUNT ||
        dataset.length > constant_1.MAX_POINT_COUNT ||
        (colorItemsLen > constant_1.LEGEND_MAX_COUNT && dataset.length > constant_1.LEGEND_MAX_POINT_COUNT)) {
        return {
            error: true,
            errorMsg: `数据量或图例项过多，请使用表格展示。`
        };
    }
    const colorItemsList = (0, fieldUtils_1.legendProduct)(colorFieldsValues, true);
    let colorItems = colorItemsList.map(d => d.join('-'));
    if (colorFields.length > 0) {
        dataset = dataset.map((data) => {
            const colorItem = colorFields.map(field => data[field]).join('-');
            return {
                ...data,
                [constant_1.COLOR_FIELD]: colorItem
            };
        });
        const _colorItems = (0, fieldUtils_1.getDomainFromDataset)(dataset, constant_1.COLOR_FIELD);
        colorItems = colorItems.filter((d) => _colorItems.includes(d));
        aliasMap[constant_1.COLOR_FIELD] = `图例项`;
        cell.color.push(constant_1.COLOR_FIELD);
        cell.cartesianInfo = (0, fieldUtils_1.getCartesianInfo)(colorFields, constant_1.COLOR_FIELD);
        cell.foldInfo = (0, fieldUtils_1.getFoldInfo)(measureIdList, constant_1.FOLD_NAME, [constant_1.FOLD_VALUE_MAIN, constant_1.FOLD_VALUE_SUB], aliasMap);
    }
    return {
        dataset,
        cell,
        colorItems,
        aliasMap
    };
};
exports.assignDualAxis = assignDualAxis;
