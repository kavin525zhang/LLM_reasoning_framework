"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTemporal = exports.unique = exports.calQuantile = exports.calCoefficient = exports.calStandardDeviation = exports.calMean = exports.restoreDatasets = exports.isNaN = void 0;
const vutils_1 = require("@visactor/vutils");
function isNaN(value) {
    return (0, vutils_1.isNumber)(value) && value != +value;
}
exports.isNaN = isNaN;
const restoreDataItem = item => {
    if (!Array.isArray(item)) {
        return item;
    }
    return item.reduce((prev, cur) => prev.concat(restoreDataItem(cur)), []);
};
const restoreDatasets = dataset => restoreDataItem(dataset);
exports.restoreDatasets = restoreDatasets;
const calMean = dataset => {
    const { data } = dataset;
    const dataNotNull = data.filter(each => !(0, vutils_1.isNil)(each) && !isNaN(each));
    const sum = dataNotNull.reduce((prev, cur) => prev + cur, 0);
    const { length } = data;
    return sum / length;
};
exports.calMean = calMean;
const calStandardDeviation = dataset => {
    const { data } = dataset;
    if (data.length === 1)
        return 0;
    const dataNotNull = data.filter(each => !(0, vutils_1.isNil)(each) && !isNaN(each));
    const mean = dataset.mean ? dataset.mean : (0, exports.calMean)(dataset);
    const sumpow = dataNotNull.reduce((prev, cur) => prev + (cur - mean) ** 2, 0);
    const { length } = data;
    return Math.sqrt(sumpow / (length - 1));
};
exports.calStandardDeviation = calStandardDeviation;
const calCoefficient = dataset => {
    const mean = dataset.mean ? dataset.mean : (0, exports.calMean)(dataset);
    const standardDev = dataset.standardDev ? dataset.standardDev : (0, exports.calStandardDeviation)(dataset);
    if (mean !== 0) {
        return standardDev / mean;
    }
    else {
        return undefined;
    }
};
exports.calCoefficient = calCoefficient;
const asc = arr => arr.sort((a, b) => a - b);
const calQuantile = (dataset, q) => {
    const { data = [] } = dataset;
    const sorted = asc((0, vutils_1.cloneDeep)(data.map(Math.abs))).filter(each => each && each > 0);
    const pos = (sorted.length - 1) * q;
    const base = Math.floor(pos);
    const rest = pos - base;
    if (sorted[base + 1] !== undefined) {
        return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
    }
    else {
        return sorted[base];
    }
};
exports.calQuantile = calQuantile;
const unique = arr => (0, vutils_1.uniqArray)(arr);
exports.unique = unique;
const isTemporal = (type) => type === 'date';
exports.isTemporal = isTemporal;
