"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dataUtils = exports.ChartType = exports.chartAdvisor = exports.GROUP_FIELD = exports.FOLD_VALUE_SUB = exports.FOLD_VALUE_MAIN = exports.COLOR_FIELD = exports.FOLD_VALUE = exports.FOLD_NAME = exports.omit = exports.fold = void 0;
const type_1 = require("./type");
Object.defineProperty(exports, "ChartType", { enumerable: true, get: function () { return type_1.ChartType; } });
const score_1 = require("./score");
const dataUtils = __importStar(require("./dataUtil"));
exports.dataUtils = dataUtils;
const vutils_1 = require("@visactor/vutils");
const dataUtil_1 = require("./dataUtil");
var fieldUtils_1 = require("./fieldUtils");
Object.defineProperty(exports, "fold", { enumerable: true, get: function () { return fieldUtils_1.fold; } });
Object.defineProperty(exports, "omit", { enumerable: true, get: function () { return fieldUtils_1.omit; } });
var constant_1 = require("./constant");
Object.defineProperty(exports, "FOLD_NAME", { enumerable: true, get: function () { return constant_1.FOLD_NAME; } });
Object.defineProperty(exports, "FOLD_VALUE", { enumerable: true, get: function () { return constant_1.FOLD_VALUE; } });
Object.defineProperty(exports, "COLOR_FIELD", { enumerable: true, get: function () { return constant_1.COLOR_FIELD; } });
Object.defineProperty(exports, "FOLD_VALUE_MAIN", { enumerable: true, get: function () { return constant_1.FOLD_VALUE_MAIN; } });
Object.defineProperty(exports, "FOLD_VALUE_SUB", { enumerable: true, get: function () { return constant_1.FOLD_VALUE_SUB; } });
Object.defineProperty(exports, "GROUP_FIELD", { enumerable: true, get: function () { return constant_1.GROUP_FIELD; } });
function chartAdvisor(params) {
    var _a;
    const { originDataset, dimensionList, measureList, aliasMap = {}, maxPivotRow = 0, maxPivotColumn = 0, purpose = type_1.UserPurpose.NONE, screen = type_1.ScreenSize.LARGE, scorer = score_1.scorer } = params;
    const measureDatasets = [];
    measureList.forEach(measure => {
        const uniqueID = measure.uniqueId;
        const measureSet = {
            data: []
        };
        measureSet.uniqueID = uniqueID;
        originDataset.forEach(row => {
            if (row.hasOwnProperty(uniqueID)) {
                measureSet.data.push(parseFloat(row[uniqueID]));
            }
        });
        const dataNotNull = measureSet.data.filter(each => !(0, vutils_1.isNil)(each) && !(0, dataUtil_1.isNaN)(each));
        measureSet.min = Math.min(...dataNotNull);
        measureSet.max = Math.max(...dataNotNull);
        measureSet.mean = dataUtils.calMean(measureSet);
        measureSet.standardDev = dataUtils.calStandardDeviation(measureSet);
        measureSet.coefficient = dataUtils.calCoefficient(measureSet);
        measureSet.Q1 = dataUtils.calQuantile(measureSet, 0.25);
        measureDatasets.push(measureSet);
    });
    const dimensionDatasets = [];
    dimensionList.forEach(dimension => {
        const uniqueID = dimension.uniqueId;
        const dimensionSet = {
            data: []
        };
        dimensionSet.uniqueID = uniqueID;
        originDataset.forEach(row => {
            dimensionSet.data.push(row[uniqueID]);
        });
        dimensionSet.dataType = dimension.type;
        dimensionSet.dimensionName = aliasMap[uniqueID];
        dimensionSet.cardinal = dataUtils.unique(dimensionSet.data).length;
        dimensionSet.ratio = dimensionSet.cardinal / dimensionSet.data.length;
        dimensionSet.isGeoField = !!dimension.isGeoField;
        dimensionDatasets.push(dimensionSet);
    });
    try {
        const scores = scorer({
            inputDataSet: originDataset,
            dimList: dimensionDatasets,
            measureList: measureDatasets,
            aliasMap,
            maxRowNum: maxPivotRow,
            maxColNum: maxPivotColumn,
            purpose,
            screen
        }).map(calculator => {
            const score = calculator();
            return score;
        });
        scores.sort((chart1, chart2) => chart2.score - chart1.score);
        if (scores[0].score === 0) {
            return {
                chartType: type_1.ChartType.TABLE,
                scores: []
            };
        }
        return {
            chartType: scores[0].chartType,
            scores
        };
    }
    catch (exception) {
        return {
            chartType: type_1.ChartType.TABLE,
            scores: [],
            error: (_a = exception.message) !== null && _a !== void 0 ? _a : exception
        };
    }
}
exports.chartAdvisor = chartAdvisor;
