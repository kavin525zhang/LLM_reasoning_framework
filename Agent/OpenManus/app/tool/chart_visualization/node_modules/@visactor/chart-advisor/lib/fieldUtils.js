"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fold = exports.getFoldInfo = exports.getCartesianInfo = exports.removeDatasetField = exports.retainDatasetField = exports.getDomainFromDataset = exports.legendProduct = exports.productLength = exports.omit = void 0;
const vutils_1 = require("@visactor/vutils");
function omit(obj, arr) {
    if ((0, vutils_1.isNil)(obj) || (0, vutils_1.isNil)(arr)) {
        return obj;
    }
    return Object.keys(obj)
        .filter(k => !arr.includes(k))
        .reduce((res, key) => ((res[key] = obj[key]), res), {});
}
exports.omit = omit;
const productLength = (list) => list.length === 0 ? 0 : list.map(d => d.length).reduce((pre, cur) => pre * cur, 1);
exports.productLength = productLength;
const legendProduct = (list, hasMeasureName = false) => {
    if (hasMeasureName && list.length > 1) {
        const _list = [...list];
        const measureNames = _list.pop();
        const productResult = product(_list);
        return measureNames
            .map((measureName) => productResult.map((d) => d.concat(measureName)))
            .reduce((pre, cur) => pre.concat(cur), []);
    }
    return product(list);
};
exports.legendProduct = legendProduct;
const product = (list) => list.length === 0
    ? []
    : list.reduce(function (a, b) {
        return a
            .map(function (x) {
            return b.map(function (y) {
                return x.concat(y);
            });
        })
            .reduce(function (a, b) {
            return a.concat(b);
        }, []);
    }, [[]]);
const getDomainFromDataset = (dataset, dim) => {
    const values = dataset.map((d) => String(d[dim]));
    return (0, vutils_1.uniqArray)(values);
};
exports.getDomainFromDataset = getDomainFromDataset;
const retainDatasetField = (dataset, fields) => dataset.map((data) => (0, vutils_1.pick)(data, fields));
exports.retainDatasetField = retainDatasetField;
const removeDatasetField = (dataset, fields) => dataset.map((data) => omit(data, fields));
exports.removeDatasetField = removeDatasetField;
const getCartesianInfo = (fieldList, key) => ({
    key,
    fieldList
});
exports.getCartesianInfo = getCartesianInfo;
const getFoldInfo = (measuresId, foldName, foldValue, aliasMap) => ({
    key: foldName,
    value: foldValue,
    foldMap: strMap2Obj(new Map(measuresId.map(id => [id, aliasMap[id]])))
});
exports.getFoldInfo = getFoldInfo;
const strMap2Obj = strMap => {
    const obj = Object.create(null);
    for (const [k, v] of strMap) {
        obj[k] = v;
    }
    return obj;
};
const fold = (dataset, fields, foldName, foldValue, aliasMap, retains = true) => {
    const _dataset = [];
    dataset.forEach((data) => {
        fields.forEach((field) => {
            const _data = retains ? data : omit(data, fields);
            _dataset.push({
                ..._data,
                [foldName]: aliasMap ? aliasMap[field] : field,
                [foldValue]: data[field]
            });
        });
    });
    return _dataset;
};
exports.fold = fold;
