"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.scorer = void 0;
const dataUtil_1 = require("./dataUtil");
const vutils_1 = require("@visactor/vutils");
const type_1 = require("./type");
const dataUtils = __importStar(require("./dataUtil"));
const fieldAssign_1 = require("./fieldAssign");
const constant_1 = require("./constant");
const fieldUtils_1 = require("./fieldUtils");
const pivot_1 = require("./pivot");
const scorer = params => {
    const { inputDataSet, dimList, measureList, aliasMap = {}, maxRowNum = 0, maxColNum = 0, purpose = type_1.UserPurpose.NONE, screen = type_1.ScreenSize.LARGE } = params;
    const datasetWithoutFold = (0, vutils_1.cloneDeep)(inputDataSet);
    let originDataset = inputDataSet;
    if (measureList.length > 1 && !originDataset[0].hasOwnProperty(constant_1.FOLD_NAME)) {
        originDataset = (0, fieldUtils_1.fold)(originDataset, measureList.map(measure => measure.uniqueID), constant_1.FOLD_NAME, constant_1.FOLD_VALUE, aliasMap, false);
    }
    const timeDim = [];
    const noneTimeDim = [];
    dimList.forEach(dim => {
        if ((0, dataUtil_1.isTemporal)(dim.dataType)) {
            timeDim.push(dim.uniqueID);
        }
        else {
            noneTimeDim.push(dim.uniqueID);
        }
    });
    const uniqueIdMap = {};
    dimList.forEach(dim => {
        uniqueIdMap[dim.uniqueID] = dim;
    });
    measureList.forEach(measure => {
        uniqueIdMap[measure.uniqueID] = measure;
    });
    const dimensionID = dimList.map(dim => dim.uniqueID);
    const measureID = measureList.map(measure => measure.uniqueID);
    const pivotChartData = (0, fieldAssign_1.assignPivotCharts)(originDataset, dimensionID, measureID, aliasMap, maxRowNum, maxColNum);
    const { dataset, colorItems, error, errMsg, aliasMap: newAliasMap } = pivotChartData;
    let { cell } = pivotChartData;
    const colList = error ? [] : cell.column;
    const rowList = error ? [] : cell.row;
    const emptyCell = {
        x: [],
        y: [],
        column: [],
        row: [],
        color: [],
        size: [],
        angle: []
    };
    if (error) {
        cell = emptyCell;
    }
    const { datasets: pivotDataSet, colPivotTree, rowPivotTree } = (0, pivot_1.pivot)(dataset, colList, rowList, cell.y);
    const calBarParallel = () => {
        let score = 0;
        const scoreDetails = {};
        let totalScore = 0;
        if (error) {
            return {
                chartType: type_1.ChartType.COLUMN_PARALLEL,
                originScore: 0,
                score: 0,
                fullMark: 0,
                scoreDetails,
                error: error ? errMsg : null
            };
        }
        const measureLength = measureList.length;
        const rule1Score = 1.0;
        totalScore += rule1Score;
        if (cell.x.length > 0 && cell.y.length > 0) {
            score += rule1Score;
            scoreDetails.rule1 = rule1Score;
        }
        else {
            return {
                chartType: type_1.ChartType.COLUMN_PARALLEL,
                originScore: 0,
                score: 0,
                fullMark: 0,
                scoreDetails
            };
        }
        const rule2Score = 3.0;
        totalScore += rule2Score;
        let maxMax = Math.max(...measureList.map(measure => Math.abs(measure.max)));
        let minQ1 = Math.min(...measureList.map(measure => Math.abs(measure.Q1)));
        if (maxMax === 0) {
            maxMax = 1;
        }
        if (minQ1 === 0) {
            minQ1 = 1;
        }
        if (maxMax / minQ1 < 100) {
            score += rule2Score;
            scoreDetails.rule2 = rule2Score;
        }
        const rule3Score = 4.0;
        totalScore += rule3Score;
        const colorSize = cell.color.length > 0 ? dataUtils.unique(dataset.map(data => data[constant_1.COLOR_FIELD])).length : 1;
        const axisSize = dataUtils.unique(uniqueIdMap[cell.x[0]].data).length;
        const dataSize = colorSize * axisSize;
        if (dataSize <= constant_1.MAX_BAR_NUMBER && dataSize >= constant_1.MIN_BAR_NUMBER) {
            score += rule3Score;
            scoreDetails.rule4 = rule3Score;
        }
        return {
            chartType: type_1.ChartType.COLUMN_PARALLEL,
            score: score / totalScore,
            fullMark: totalScore,
            originScore: score,
            scoreDetails,
            cell,
            dataset
        };
    };
    const calBarPercent = () => {
        let score = 0;
        let totalScore = 0;
        const scoreDetails = {};
        if (error) {
            return {
                chartType: type_1.ChartType.COLUMN_PERCENT,
                originScore: 0,
                fullMark: 0,
                score: 0,
                scoreDetails,
                error: error ? errMsg : null
            };
        }
        const dimensionLength = dimList.length - cell.row.length - cell.column.length;
        const measureLength = measureList.length;
        const rule1Score = 1.0;
        totalScore += rule1Score;
        if (dimensionLength > 1 && measureLength > 0) {
            score += rule1Score;
            scoreDetails.rule1 = rule1Score;
        }
        else {
            return {
                chartType: type_1.ChartType.COLUMN_PERCENT,
                score: 0,
                fullMark: 0,
                originScore: 0,
                scoreDetails
            };
        }
        const rule2Score = 3.0;
        totalScore += rule2Score;
        let maxMax = Math.max(...measureList.map(measure => Math.abs(measure.max)));
        let minQ1 = Math.min(...measureList.map(measure => Math.abs(measure.Q1)));
        if (maxMax === 0) {
            maxMax = 1;
        }
        if (minQ1 === 0) {
            minQ1 = 1;
        }
        if (maxMax / minQ1 < 100) {
            score += rule2Score;
            scoreDetails.rule2 = rule2Score;
        }
        const rule3Score = 1.0;
        totalScore += rule3Score;
        const axisSize = dataUtils.unique(uniqueIdMap[cell.x[0]].data).length;
        const dataSize = axisSize * measureLength;
        if (dataSize <= constant_1.MAX_BAR_NUMBER && dataSize >= constant_1.MIN_BAR_NUMBER) {
            score += rule3Score;
            scoreDetails.rule3 = rule3Score;
        }
        const rule4Score = 1.0;
        totalScore += rule4Score;
        const colorSize = cell.color.length > 0 ? dataUtils.unique(dataset.map(data => data[constant_1.COLOR_FIELD])).length : 1;
        if (colorSize <= constant_1.MAX_BAR_NUMBER) {
            score += rule4Score;
            scoreDetails.rule4 = rule4Score;
        }
        const rule5Score = 1.0;
        totalScore += rule5Score;
        if (purpose === type_1.UserPurpose.PROPORTION) {
            score += rule5Score;
            scoreDetails.rule5 = rule5Score;
        }
        return {
            chartType: type_1.ChartType.COLUMN_PERCENT,
            score: score / totalScore,
            originScore: score,
            fullMark: totalScore,
            scoreDetails,
            cell,
            dataset
        };
    };
    const calBar = () => {
        let score = 0;
        let totalScore = 0;
        const scoreDetails = {};
        if (error) {
            return {
                chartType: type_1.ChartType.COLUMN,
                score: 0,
                scoreDetails,
                fullMark: 0,
                originScore: 0,
                error: error ? errMsg : ''
            };
        }
        const dimensionLength = dimList.length - cell.row.length - cell.column.length;
        const measureLength = measureList.length;
        const rule1Score = 1.0;
        totalScore += rule1Score;
        if (dimensionLength >= 1 && measureLength >= 1) {
            score += rule1Score;
            scoreDetails.rule1 = rule1Score;
        }
        else {
            return {
                chartType: type_1.ChartType.COLUMN,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0
            };
        }
        const rule2Score = 3.0;
        totalScore += rule2Score;
        let maxMax = Math.max(...measureList.map(measure => Math.abs(measure.max)));
        let minQ1 = Math.min(...measureList.map(measure => Math.abs(measure.Q1)));
        if (maxMax === 0) {
            maxMax = 1;
        }
        if (minQ1 === 0) {
            minQ1 = 1;
        }
        if (maxMax / minQ1 < 100) {
            score += rule2Score;
            scoreDetails.rule2 = rule2Score;
        }
        const rule3Score = 1.0;
        totalScore += rule3Score;
        const axisSize = dataUtils.unique(uniqueIdMap[cell.x[0]].data).length;
        const dataSize = measureLength * axisSize;
        if (dataSize <= constant_1.MAX_BAR_NUMBER && dataSize >= constant_1.MIN_BAR_NUMBER) {
            score += rule3Score;
            scoreDetails.rule3 = rule3Score;
        }
        const rule4Score = 1.0;
        totalScore += rule4Score;
        const colorSize = cell.color.length > 0 ? dataUtils.unique(dataset.map(data => data[constant_1.COLOR_FIELD])).length : 1;
        if (colorSize <= constant_1.MAX_BAR_NUMBER) {
            score += rule4Score;
            scoreDetails.rule4 = rule4Score;
        }
        const rule5Score = 1.0;
        totalScore += rule5Score;
        if (screen === type_1.ScreenSize.SMALL) {
            score += rule5Score;
            scoreDetails.rule4 = rule5Score;
        }
        return {
            chartType: type_1.ChartType.COLUMN,
            score: score / totalScore,
            originScore: score,
            fullMark: totalScore,
            scoreDetails,
            cell,
            dataset
        };
    };
    const calCombination = () => {
        let score = 0;
        let totalScore = 0;
        const scoreDetails = {};
        if (error) {
            return {
                chartType: type_1.ChartType.COMBINATION,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0,
                error: error ? errMsg : null
            };
        }
        const measureLength = measureList.length;
        const rule1Score = 1.0;
        totalScore += rule1Score;
        if (measureLength > 1 && cell.x.length > 0) {
            score += rule1Score;
            scoreDetails.rule1 = rule1Score;
        }
        else {
            return {
                chartType: type_1.ChartType.COMBINATION,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0
            };
        }
        const rule2Score = 1.0;
        totalScore += rule2Score;
        let minQ1 = Math.min(...measureList.map(measure => Math.abs(measure.Q1)));
        let maxMax = Math.max(...measureList.map(measure => Math.abs(measure.max)));
        if (maxMax === 0) {
            maxMax = 1;
        }
        if (minQ1 === 0) {
            minQ1 = 1;
        }
        if (maxMax / minQ1 > 100) {
            score += rule2Score;
            scoreDetails.rule2 = rule2Score;
        }
        const rule3Score = 3.0;
        totalScore += rule3Score;
        const score3Flag = measureList.reduce((prev, cur) => {
            if (prev) {
                return cur.min / cur.max > 0.01;
            }
            return false;
        }, true);
        if (score3Flag) {
            score += rule3Score;
            scoreDetails.rule3 = rule3Score;
        }
        const rule4Score = 1.0;
        totalScore += rule4Score;
        const colorSize = cell.color.length > 0 ? dataUtils.unique(dataset.map(data => data[constant_1.COLOR_FIELD])).length : 1;
        const axisSize = dataUtils.unique(uniqueIdMap[cell.x[0]].data).length;
        const dataSize = axisSize * colorSize;
        if (dataSize <= constant_1.MAX_BAR_NUMBER && dataSize >= constant_1.MIN_BAR_NUMBER) {
            score += rule4Score;
            scoreDetails.rule4 = rule4Score;
        }
        const combineMetadata = (0, fieldAssign_1.processCombination)(datasetWithoutFold, dimensionID, measureID, aliasMap, maxRowNum, maxColNum);
        const combineDatasets = combineMetadata.map(metaData => metaData.dataset);
        const combineCells = combineMetadata.map(metaData => metaData.cell);
        const { datasets: combinePivotDataSet, colPivotTree, rowPivotTree } = (0, pivot_1.pivotCombination)(combineDatasets, colList, rowList);
        return {
            chartType: type_1.ChartType.COMBINATION,
            score: score / totalScore,
            scoreDetails,
            originScore: score,
            fullMark: totalScore,
            cell: combineCells,
            dataset: combinePivotDataSet
        };
    };
    const calScatterplot = () => {
        let score = 0;
        let totalScore = 0;
        const scoreDetails = {};
        const dimensionID = dimList.map(dim => dim.uniqueID);
        const measureID = measureList.map(measure => measure.uniqueID);
        const scatterData = (0, fieldAssign_1.assignScatterPlot)(datasetWithoutFold, dimensionID, measureID, aliasMap);
        const { scatterCell, dataset, colorItems, aliasMap: newAliasMap, error, errMsg } = scatterData;
        if (error) {
            return {
                chartType: type_1.ChartType.SCATTER,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0,
                error: error ? errMsg : null
            };
        }
        const rule1Score = 1.0;
        totalScore += rule1Score;
        if (scatterCell.x.length > 0 && scatterCell.y.length > 0) {
            score += rule1Score;
            scoreDetails.rule1 = rule1Score;
        }
        else {
            return {
                chartType: type_1.ChartType.SCATTER,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0
            };
        }
        const rule2Score = 1.0;
        totalScore += rule2Score;
        if (datasetWithoutFold.length >= 30 && datasetWithoutFold.length <= 1000) {
            score += rule2Score;
            scoreDetails.rule2 = rule2Score;
        }
        return {
            chartType: type_1.ChartType.SCATTER,
            score: score / totalScore,
            scoreDetails,
            originScore: score,
            fullMark: totalScore,
            cell: scatterCell,
            dataset
        };
    };
    const calLineChart = () => {
        let score = 0;
        let totalScore = 0;
        const scoreDetails = {};
        const lineChartDimID = (0, fieldAssign_1.sortTimeDim)(dimList, maxRowNum, maxColNum);
        const { cell: lineChartCell, dataset: lineDataset, error, errMsg } = (0, fieldAssign_1.assignPivotCharts)(originDataset, lineChartDimID, measureID, aliasMap, maxRowNum, maxColNum);
        if (error) {
            return {
                chartType: type_1.ChartType.LINE,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0,
                error: error ? errMsg : null
            };
        }
        const rule1Score = 2.0;
        totalScore += rule1Score - 1.0;
        const _colorItems = (0, fieldUtils_1.getDomainFromDataset)(lineDataset, constant_1.COLOR_FIELD);
        const colorItemCardinal = lineDataset.hasOwnProperty(constant_1.COLOR_FIELD) ? dataUtils.unique(_colorItems).length : 1;
        if (timeDim.length > 0 && cell.y.length > 0 && colorItemCardinal <= 50) {
            score += rule1Score;
            scoreDetails.rule1 = rule1Score;
        }
        else {
            return {
                chartType: type_1.ChartType.LINE,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0
            };
        }
        const rule2Score = 1.0;
        if (measureList.length > 1) {
            totalScore += rule2Score;
            let minQ1 = Math.min(...measureList.map(measure => Math.abs(measure.Q1)));
            let maxMax = Math.max(...measureList.map(measure => Math.abs(measure.max)));
            if (minQ1 === 0) {
                minQ1 = 1;
            }
            if (maxMax === 0) {
                maxMax = 1;
            }
            if (maxMax / minQ1 <= 100) {
                score += rule2Score;
                scoreDetails.rule2 = rule2Score;
            }
        }
        const rule3Score = 1.0;
        totalScore += rule3Score;
        const coefficientFlag = measureList.reduce((prev, cur) => {
            if (!prev) {
                return false;
            }
            else {
                if (cur.coefficient) {
                    return cur.coefficient >= 0.2;
                }
                else {
                    return true;
                }
            }
        }, true);
        if (coefficientFlag) {
            score += rule3Score;
            scoreDetails.rule3 = rule3Score;
        }
        const { datasets: lineChartDataset, colPivotTree, rowPivotTree } = (0, pivot_1.pivot)(lineDataset, colList, rowList, lineChartCell.y);
        return {
            chartType: type_1.ChartType.LINE,
            score: score / totalScore,
            originScore: score,
            fullMark: totalScore,
            scoreDetails,
            cell: lineChartCell,
            dataset: lineDataset
        };
    };
    const calLineChartCombine = () => {
        let score = 0;
        let totalScore = 0;
        const scoreDetails = {};
        const lineChartDimID = (0, fieldAssign_1.sortTimeDim)(dimList, maxRowNum, maxColNum);
        const { cell: lineChartCell, dataset: lineDataset, error, errMsg } = (0, fieldAssign_1.assignPivotCharts)(originDataset, lineChartDimID, measureID, aliasMap, maxRowNum, maxColNum);
        if (error) {
            return {
                chartType: type_1.ChartType.LINE,
                score: 0,
                scoreDetails,
                fullMark: 0,
                originScore: 0,
                error: error ? errMsg : null
            };
        }
        const rule1Score = 2.0;
        totalScore += rule1Score - 1.0;
        const _colorItems = (0, fieldUtils_1.getDomainFromDataset)(lineDataset, constant_1.COLOR_FIELD);
        const colorItemCardinal = lineDataset.hasOwnProperty(constant_1.COLOR_FIELD) ? dataUtils.unique(_colorItems).length : 1;
        if (timeDim.length > 0 && cell.y.length > 0 && colorItemCardinal <= 50) {
            score += rule1Score;
            scoreDetails.rule1 = rule1Score;
        }
        else {
            return {
                chartType: type_1.ChartType.LINE,
                score: 0,
                scoreDetails,
                fullMark: 0,
                originScore: 0
            };
        }
        const rule2Score = 1.0;
        if (measureList.length > 1) {
            totalScore += rule2Score;
            let minQ1 = Math.min(...measureList.map(measure => Math.abs(measure.Q1)));
            let maxMax = Math.max(...measureList.map(measure => Math.abs(measure.max)));
            if (minQ1 === 0) {
                minQ1 = 1;
            }
            if (maxMax === 0) {
                maxMax = 1;
            }
            if (maxMax / minQ1 > 100) {
                score += rule2Score;
                scoreDetails.rule2 = rule2Score;
            }
        }
        const rule3Score = 1.0;
        totalScore += rule3Score;
        const coefficientFlag = measureList.reduce((prev, cur) => {
            if (!prev) {
                return false;
            }
            else {
                if (cur.coefficient) {
                    return cur.coefficient >= 0.2;
                }
                else {
                    return true;
                }
            }
        }, true);
        if (coefficientFlag) {
            score += rule3Score;
            scoreDetails.rule3 = rule3Score;
        }
        const combineMetadata = (0, fieldAssign_1.processCombination)(datasetWithoutFold, lineChartDimID, measureID, aliasMap, maxRowNum, maxColNum);
        const combineDatasets = combineMetadata.map(metaData => metaData.dataset);
        const { datasets: combinePivotDataSet, colPivotTree, rowPivotTree } = (0, pivot_1.pivotCombination)(combineDatasets, colList, rowList);
        return {
            chartType: type_1.ChartType.EXTEND,
            score: score / totalScore,
            scoreDetails,
            originScore: score,
            fullMark: totalScore
        };
    };
    const calPieChart = () => {
        let score = 0;
        let totalScore = 0;
        const scoreDetails = {};
        const pieChartData = (0, fieldAssign_1.assignPieChart)(originDataset, dimensionID, measureID, aliasMap);
        const { pieCell, dataset: pieDataset, colorItems, aliasMap: newAliasMap, error, errMsg } = pieChartData;
        if (error) {
            return {
                chartType: type_1.ChartType.PIE,
                score: 0,
                scoreDetails,
                fullMark: 0,
                originScore: 0,
                error: error ? errMsg : null
            };
        }
        const rule1Score = 2.0;
        totalScore += rule1Score;
        if (dimList.length === 0 && measureList.length >= 3) {
            score += rule1Score;
            scoreDetails.rule1 = rule1Score;
        }
        else {
            return {
                chartType: type_1.ChartType.PIE,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0
            };
        }
        const rule2Score = 2.0;
        totalScore += rule2Score;
        if (measureList.length <= 20) {
            score += rule2Score;
            scoreDetails.rule2 = rule2Score;
        }
        const rule3Score = 3.0;
        totalScore += rule3Score;
        measureList.map(measure => measure.min);
        const minMeasure = Math.min(...measureList.map(measure => measure.min));
        const maxMeasure = Math.max(...measureList.map(measure => measure.max));
        if (minMeasure / maxMeasure > 0.1) {
            score += rule3Score;
            scoreDetails.rule3 = rule3Score;
        }
        const rule4Score = 1.0;
        totalScore += rule4Score;
        if (dimList.length === 0) {
            const tempDataset = {
                data: measureList.reduce((prev, cur) => prev.concat(cur.data), [])
            };
            const coefficient = dataUtils.calCoefficient(tempDataset);
            if (!coefficient || coefficient > 0.2) {
                score += rule4Score;
                scoreDetails.rule4 = rule4Score;
            }
        }
        return {
            chartType: type_1.ChartType.PIE,
            score: score / totalScore,
            originScore: score,
            fullMark: totalScore,
            scoreDetails,
            cell: pieCell,
            dataset: pieDataset
        };
    };
    const calMeasureCard = () => {
        let score = 0;
        let totalScore = 0;
        const scoreDetails = {};
        const rule1Score = 2.0;
        totalScore += rule1Score;
        if (dimList.length === 0 && measureList.length <= 3 && measureList.length >= 1) {
            score += rule1Score;
            scoreDetails.rule1 = rule1Score;
        }
        else {
            return {
                chartType: type_1.ChartType.MEASURE_CARD,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0
            };
        }
        const cardData = (0, fieldAssign_1.assignMeasureCard)(datasetWithoutFold, dimensionID, measureID, aliasMap);
        const { cardCell, dataset: cardDataset } = cardData;
        return {
            chartType: type_1.ChartType.MEASURE_CARD,
            score: score / totalScore,
            originScore: score,
            fullMark: totalScore,
            scoreDetails,
            cell: cardCell,
            dataset: cardDataset
        };
    };
    const calRadar = () => {
        let score = 0;
        let totalScore = 0;
        const scoreDetails = {};
        if (error) {
            return {
                chartType: type_1.ChartType.RADAR,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0,
                error: error ? errMsg : null
            };
        }
        const rule1Score = 1.0;
        totalScore += rule1Score;
        if (cell.x.length > 0 && cell.y.length > 0) {
            score += rule1Score;
            scoreDetails.rule1 = rule1Score;
        }
        else {
            return {
                chartType: type_1.ChartType.RADAR,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0
            };
        }
        const rule2Score = 5.0;
        totalScore += rule2Score;
        if (purpose === type_1.UserPurpose.DISTRIBUTION) {
            score += rule2Score;
            scoreDetails.rule2 = rule2Score;
        }
        return {
            chartType: type_1.ChartType.RADAR,
            score: score / totalScore,
            fullMark: totalScore,
            originScore: score,
            scoreDetails,
            cell,
            dataset
        };
    };
    const calWordCloud = () => {
        let score = 0;
        let totalScore = 0;
        const scoreDetails = {};
        const rule1Score = 1.0;
        totalScore += rule1Score;
        if (dimList.length === 1 && measureList.length == 0) {
            score += rule1Score;
            scoreDetails.rule1 = rule1Score;
        }
        else {
            return {
                chartType: type_1.ChartType.WORD_CLOUD,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0
            };
        }
        const rule2Score = 2.0;
        totalScore += rule2Score;
        if (dimList[0].cardinal >= 20 && dimList[0].cardinal <= 100) {
            score += rule2Score;
            scoreDetails.rule2 = rule2Score;
        }
        const rule3Score = 5.0;
        totalScore += rule3Score;
        if (purpose === type_1.UserPurpose.STORYTELLING) {
            score += rule3Score;
            scoreDetails.rule3 = rule3Score;
        }
        const wordCloudCell = {
            x: [],
            y: [],
            row: [],
            column: [],
            color: [],
            size: [],
            angle: []
        };
        wordCloudCell.color.push(dimList[0].uniqueID);
        if (measureList.length > 0) {
            wordCloudCell.size.push(measureList[0].uniqueID);
        }
        return {
            chartType: type_1.ChartType.WORD_CLOUD,
            score: score / totalScore,
            originScore: score,
            fullMark: totalScore,
            scoreDetails,
            cell: wordCloudCell,
            dataset
        };
    };
    const calFunnelChart = () => {
        let score = 0;
        let totalScore = 0;
        const scoreDetails = {};
        const rule1Score = 1.0;
        totalScore += rule1Score;
        if ((dimList.length === 1 && measureList.length === 1) || (dimList.length === 0 && measureList.length >= 2)) {
            score += rule1Score;
            scoreDetails.rule1 = rule1Score;
        }
        else {
            return {
                chartType: type_1.ChartType.FUNNEL,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0
            };
        }
        const rule2Score = 5.0;
        totalScore += rule2Score;
        if (purpose === type_1.UserPurpose.TREND) {
            score += rule2Score;
            scoreDetails.rule2 = rule2Score;
        }
        const { funnelCell, dataset: funnelDataset } = (0, fieldAssign_1.assignFunnelChart)(originDataset, dimensionID, measureID, aliasMap);
        return {
            chartType: type_1.ChartType.FUNNEL,
            score: score / totalScore,
            originScore: score,
            fullMark: totalScore,
            scoreDetails,
            cell: funnelCell,
            dataset: funnelDataset
        };
    };
    const calDualAxis = () => {
        let score = 0;
        let totalScore = 0;
        const scoreDetails = {};
        if (!(measureList.length === 2 && dimList.length > 0)) {
            return {
                chartType: type_1.ChartType.DUAL_AXIS,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0
            };
        }
        const dualAxisData = (0, fieldAssign_1.assignDualAxis)(datasetWithoutFold, dimensionID, [measureID[0]], [measureID[1]], aliasMap);
        const { error: newError, errorMsg, dataset, cell: newCell, colorItems, aliasMap: newAliasMap } = dualAxisData;
        if (newError) {
            return {
                chartType: type_1.ChartType.DUAL_AXIS,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0,
                error: error ? errMsg : null
            };
        }
        const measureLength = measureList.length;
        const rule1Score = 1.0;
        totalScore += rule1Score;
        if (measureLength === 2 && newCell.x.length > 0) {
            score += rule1Score;
            scoreDetails.rule1 = rule1Score;
        }
        else {
            return {
                chartType: type_1.ChartType.DUAL_AXIS,
                score: 0,
                scoreDetails,
                originScore: 0,
                fullMark: 0
            };
        }
        const rule2Score = 1.0;
        totalScore += rule2Score;
        let minQ1 = Math.min(...measureList.map(measure => Math.abs(measure.Q1)));
        let maxMax = Math.max(...measureList.map(measure => Math.abs(measure.max)));
        if (minQ1 === 0) {
            minQ1 = 1;
        }
        if (maxMax === 0) {
            maxMax = 1;
        }
        if (maxMax / minQ1 > 100) {
            score += rule2Score;
            scoreDetails.rule2 = rule2Score;
        }
        const rule4Score = 1.0;
        totalScore += rule4Score;
        const colorSize = newCell.color.length > 0 ? dataUtils.unique(dataset.map(data => data[constant_1.COLOR_FIELD])).length : 1;
        const axisSize = dataUtils.unique(uniqueIdMap[newCell.x[0]].data).length;
        const dataSize = axisSize;
        if (dataSize <= constant_1.MAX_BAR_NUMBER && dataSize >= constant_1.MIN_BAR_NUMBER) {
            score += rule4Score;
            scoreDetails.rule4 = rule4Score;
        }
        return {
            chartType: type_1.ChartType.DUAL_AXIS,
            score: score / totalScore,
            originScore: score,
            fullMark: totalScore,
            scoreDetails,
            cell: newCell,
            dataset
        };
    };
    const calTable = () => {
        let score = 0;
        let totalScore = 0;
        const scoreDetails = {};
        const rule1Score = 2.0;
        totalScore += rule1Score;
        const colorSize = cell.color.length > 0 ? dataUtils.unique(dataset.map(data => data[constant_1.COLOR_FIELD])).length : 1;
        let axisSize;
        if (cell.x.length > 0) {
            axisSize = dataUtils.unique(uniqueIdMap[cell.x[0]].data).length;
        }
        else {
            axisSize = 1;
        }
        const dataSize = colorSize * axisSize;
        if (dataSize >= 100) {
            score += rule1Score;
            scoreDetails.rule4 = rule1Score;
        }
        return {
            chartType: type_1.ChartType.TABLE,
            score: score / totalScore,
            originScore: score,
            fullMark: totalScore,
            scoreDetails,
            cell,
            dataset
        };
    };
    const scoreCalculators = [
        calBar,
        calBarPercent,
        calBarParallel,
        calScatterplot,
        calLineChart,
        calPieChart,
        calRadar,
        calWordCloud,
        calFunnelChart,
        calDualAxis
    ];
    return scoreCalculators;
};
exports.scorer = scorer;
